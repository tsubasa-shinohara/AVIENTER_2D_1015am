{"ast":null,"code":"// 物理計算関連の関数\nimport { MOTOR_THRUST_DATA, PHYSICAL_CONSTANTS, ANGLE_RESPONSE_DT, ANGLE_STEPS_PER_UPDATE, NOSE_SHAPES, FIN_MATERIALS, WIND_PROFILES, mmToM, gToKg } from './RocketConstants';\n\n// 物理制御と拡張制御を分離する定数を追加\nexport const PHYSICAL_ATTITUDE_CONTROL = true; // 物理ベースの姿勢制御 (常に有効にすべき)\nexport const ENHANCED_ATTITUDE_CONTROL = false; // 拡張姿勢制御 (風見効果など)\n\n// ロケットの投影面積を計算する関数\nexport const calculateProjectedArea = rocketParams => {\n  // パラメータの存在と型チェック\n  if (!rocketParams || typeof rocketParams !== 'object') {\n    console.error('calculateProjectedArea: 無効なrocketParamsオブジェクト', rocketParams);\n    return {\n      frontalArea: 0,\n      sideArea: 0,\n      finArea: 0,\n      totalFinArea: 0,\n      angledArea: 0\n    };\n  }\n\n  // 必須パラメータの存在チェック\n  const {\n    noseShape,\n    noseHeight,\n    bodyHeight,\n    bodyWidth,\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finSweepLength,\n    finThickness\n  } = rocketParams;\n\n  // 必須パラメータが存在しない場合はエラーログを出力し、安全な値を返す\n  if (typeof noseHeight !== 'number' || typeof bodyHeight !== 'number' || typeof bodyWidth !== 'number' || typeof finHeight !== 'number' || typeof finBaseWidth !== 'number' || typeof finTipWidth !== 'number' || typeof finThickness !== 'number' || typeof finSweepLength !== 'number') {\n    console.error('calculateProjectedArea: 必須の数値パラメータが不足しています', {\n      noseHeight,\n      bodyHeight,\n      bodyWidth,\n      finHeight,\n      finBaseWidth,\n      finTipWidth,\n      finThickness,\n      finSweepLength\n    });\n    return {\n      frontalArea: 0,\n      sideArea: 0,\n      finArea: 0,\n      totalFinArea: 0,\n      angledArea: 0\n    };\n  }\n\n  // 単位をmm->mに変換\n  const noseHeight_m = mmToM(noseHeight);\n  const bodyHeight_m = mmToM(bodyHeight);\n  const bodyWidth_m = mmToM(bodyWidth);\n  const bodyRadius_m = bodyWidth_m / 2;\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finSweepLength_m = mmToM(finSweepLength);\n\n  // 正面からの投影面積 (m^2)\n  const frontalArea = Math.PI * Math.pow(bodyRadius_m, 2) + finHeight * finThickness * 4 * 0.0000001;\n\n  // 側面投影面積の計算 (m^2)\n  // ボディ部分\n  const bodyArea = bodyWidth_m * bodyHeight_m;\n\n  // ノーズ部分 - 形状に応じて計算\n  let noseArea;\n  if (noseShape === 'cone') {\n    noseArea = 0.5 * bodyWidth_m * noseHeight_m; // 三角形の面積\n  } else if (noseShape === 'parabola') {\n    noseArea = 2 / 3 * bodyWidth_m * noseHeight_m; // 放物線の近似\n  } else {\n    // ogive\n    noseArea = 2 / 3 * bodyWidth_m * noseHeight_m; // オジブの近似\n  }\n\n  // フィン1枚あたりの投影面積\n  const finArea = finHeight_m * (finBaseWidth_m + finTipWidth_m) / 2; // 台形の面積\n\n  // フィン4枚の合計投影面積\n  const totalFinArea = finArea * 2;\n\n  // 側面からの合計投影面積\n  const sideArea = bodyArea + noseArea + totalFinArea;\n\n  // 斜め45度からの投影面積（近似）（修正が必要）\n  const angledArea = Math.sqrt(Math.pow(frontalArea, 2) + Math.pow(sideArea, 2));\n  return {\n    frontalArea,\n    // 正面からの投影面積 (m^2)\n    sideArea,\n    // 側面からの投影面積 (m^2)\n    finArea,\n    // フィン1枚の投影面積 (m^2)\n    totalFinArea,\n    // フィン4枚の合計投影面積 (m^2)\n    angledArea // 斜め45度からの投影面積（近似） (m^2)\n  };\n};\n\n// ロケットの体積を計算する関数\nexport const calculateVolume = rocketParams => {\n  const {\n    noseShape,\n    noseHeight,\n    bodyHeight,\n    bodyWidth\n  } = rocketParams;\n\n  // 単位をmm->mに変換\n  const noseHeight_m = mmToM(noseHeight);\n  const bodyHeight_m = mmToM(bodyHeight);\n  const bodyRadius_m = mmToM(bodyWidth) / 2;\n\n  // ボディ体積（円柱） (m^3)\n  const bodyVolume = Math.PI * Math.pow(bodyRadius_m, 2) * bodyHeight_m;\n\n  // ノーズ体積 - 形状に応じて計算 (m^3)\n  let noseVolume;\n  if (noseShape === 'cone') {\n    noseVolume = 1 / 3 * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // 円錐の体積\n  } else if (noseShape === 'parabola') {\n    noseVolume = 1 / 2 * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // 放物線回転体の体積\n  } else {\n    // ogive\n    noseVolume = 2 / 3 * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // オジブの近似体積\n  }\n\n  // 合計体積 (m^3)\n  const totalVolume = bodyVolume + noseVolume;\n\n  // フィンの体積は非常に小さいため、ここでは無視する\n\n  return {\n    bodyVolume,\n    // ボディ部分の体積 (m^3)\n    noseVolume,\n    // ノーズ部分の体積 (m^3)\n    totalVolume // 合計体積 (m^3)\n  };\n};\n\n// 圧力中心位置を計算する関数（モーメント計算に使用）\nexport const calculateCenterOfPressure = rocketParams => {\n  const {\n    noseShape,\n    noseHeight,\n    bodyHeight,\n    bodyWidth,\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finSweepLength\n  } = rocketParams;\n\n  // 面積と体積を計算\n  const areas = calculateProjectedArea(rocketParams);\n\n  // ノーズ先端からの各コンポーネントの圧力中心位置 (mm)\n  // ノーズの圧力中心位置 - 形状に応じて計算\n  let noseCp;\n  if (noseShape === 'cone') {\n    noseCp = noseHeight * (2 / 3); // 円錐の圧力中心はノーズ長の2/3\n  } else if (noseShape === 'parabola') {\n    noseCp = noseHeight * (3 / 5); // 放物線の圧力中心（近似値）\n  } else {\n    // ogive\n    noseCp = noseHeight * (3 / 5); // オジブの圧力中心（近似値）\n  }\n\n  // ボディの圧力中心位置（ノーズ先端から）\n  const bodyCp = noseHeight + bodyHeight / 2; // mm\n\n  //　フィンの圧力中心位置（フィン付け根先端から）\n  const finCP_single = (Math.pow(finSweepLength + finTipWidth, 2) - Math.pow(finSweepLength, 2) + Math.pow(finBaseWidth, 2) + (finSweepLength + finTipWidth) * finBaseWidth) / (3 * (finSweepLength + finTipWidth + finBaseWidth - finSweepLength)); // mm\n\n  // フィンの圧力中心位置（ノーズ先端から）\n  const finCp = noseHeight + bodyHeight - finBaseWidth + finCP_single; // mm\n\n  // 面積による重み付け計算\n  // 単位を揃えるためにm²からmm²に変換\n  const noseArea = areas.noseArea * 1000000; // m^2 → mm^2\n  const bodyArea = areas.sideArea * 1000000 - noseArea; // m^2 → mm^2\n  const totalFinArea = areas.totalFinArea * 1000000; // m^2 → mm^2\n\n  // 圧力中心の計算（重み付け平均）\n  const totalArea = noseArea + bodyArea + totalFinArea;\n  const centerOfPressure = (noseCp * noseArea + bodyCp * bodyArea + finCp * totalFinArea) / totalArea; // mm\n\n  // フィンを除いた前部の圧力中心（空力計算用）\n  const foreBodyArea = noseArea + bodyArea;\n  const foreBodyCp = (noseCp * noseArea + bodyCp * bodyArea) / foreBodyArea;\n  return {\n    noseCp,\n    // ノーズの圧力中心位置 (mm)\n    bodyCp,\n    // ボディの圧力中心位置 (mm)\n    finCp,\n    // フィンの圧力中心位置 (mm)\n    centerOfPressure,\n    // 全体の圧力中心位置 (mm)\n    foreBodyCp // フィンを除いた前部の圧力中心位置 (mm)\n  };\n};\n\n// 空力中心位置を計算する関数\nexport const calculateAerodynamicCenter = rocketParams => {\n  // この行で必要なすべてのプロパティを取り出します\n  const {\n    noseHeight,\n    bodyHeight,\n    bodyWidth,\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finSweepLength\n  } = rocketParams;\n\n  // 投影面積を計算\n  const areas = calculateProjectedArea(rocketParams);\n\n  // lengthOfCo\n  const lengthOfCo = (finBaseWidth - finTipWidth) / finHeight * (bodyWidth / 2 + finHeight) + finTipWidth;\n\n  // テーパー比（ramda）\n  const ramda = finTipWidth / lengthOfCo;\n\n  // 胴体容積 (m^3)\n  const volumeData = calculateVolume(rocketParams);\n\n  // c_bar\n  const c_bar = 2 * lengthOfCo / 3 * (1 + ramda + Math.pow(ramda, 2)) / (1 + ramda);\n\n  // y_bar\n  const y_bar = (finHeight + bodyWidth / 2) * (1 + 2 * ramda) / (3 * (1 + ramda));\n\n  // 面積による重み付け計算（m^2をmm^2に変換）\n  const noseArea = areas.noseArea * 1000000; // m^2 → mm^2\n  const bodyArea = areas.sideArea * 1000000 - noseArea; // m^2 → mm^2\n  const totalFinArea = areas.totalFinArea * 1000000; // m^2 → mm^2\n\n  // WingArea\n  const wingArea = (finTipWidth + lengthOfCo) * (bodyWidth / 2 + finHeight);\n\n  // V*fus\n  const Vstar_fus = volumeData.totalVolume * 1000000000 / (c_bar * wingArea); // 単位を合わせる\n\n  // AspectRatio\n  const aspectRatio = (2 * finHeight + bodyWidth) * (2 * finHeight + bodyWidth) / wingArea;\n\n  // CLα\n  const cl_alpha = 3.14 * aspectRatio * 0.5 * Math.pow(1 - Math.pow(bodyWidth / 2 / ((finHeight + bodyWidth / 2) / 2), 2), 2);\n\n  // hn\n  const hn = 0.25 + 1 / cl_alpha * -1 * (2 * Vstar_fus);\n\n  // hnwc_bar\n  const hnwc_bar = hn * c_bar;\n\n  // x1\n  const x1 = bodyWidth / 2 * finSweepLength / finHeight;\n\n  // x2\n  const x2 = y_bar * (x1 + finSweepLength + finTipWidth - lengthOfCo) / (bodyWidth / 2 + finHeight);\n\n  // small_xac\n  const small_xac = c_bar - x2 - hnwc_bar;\n\n  // 空力中心計算\n  const aerodynamicCenter = noseHeight + bodyHeight - small_xac;\n  return {\n    aerodynamicCenter // 空力中心位置 (mm)\n  };\n};\n\n// 静安定マージン計算用の圧力中心位置を計算する関数\nexport const calculateStabilityCenterOfPressure = rocketParams => {\n  const {\n    noseShape,\n    noseHeight,\n    bodyHeight,\n    bodyWidth,\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finSweepLength\n  } = rocketParams;\n\n  // mc\n  const mc = Math.pow(Math.pow(finSweepLength + finTipWidth / 2 - finBaseWidth / 2, 2) + Math.pow(finHeight, 2), 0.5);\n\n  // ノーズ先端からの位置を計算 (mm)\n  // この静安定マージン用の圧力中心は通常の圧力中心とは異なる計算方法を使用\n\n  // ノーズの圧力中心\n  let noseStabilityCp;\n  if (noseShape === 'cone') {\n    noseStabilityCp = noseHeight * 0.5; // 円錐の静安定用圧力中心\n  } else if (noseShape === 'parabola') {\n    noseStabilityCp = noseHeight * 0.45; // 放物線の静安定用圧力中心\n  } else {\n    // ogive\n    noseStabilityCp = noseHeight * 0.4; // オジブの静安定用圧力中心\n  }\n\n  // フィンのcn\n  const fin_cn_1 = 1 + finHeight / (finHeight + bodyWidth / 2);\n  const fin_cn_2 = 4 * 4 * Math.pow(finHeight / (bodyWidth / 2), 2);\n  const fin_cn_3 = 1 + Math.pow(1 + Math.pow(2 * mc / (finTipWidth + finBaseWidth), 2), 0.5);\n  const fin_cn = fin_cn_1 * fin_cn_2 / fin_cn_3;\n\n  // CnTotal\n  const cnTotal = 2 + fin_cn;\n\n  // フィンの圧力中心\n  const finStabilityCp = noseHeight + bodyHeight - finBaseWidth + finSweepLength / 3 * ((finBaseWidth + 2 * finTipWidth) / (finBaseWidth + finTipWidth)) + (finBaseWidth + finTipWidth - finBaseWidth * finTipWidth / (finBaseWidth + finTipWidth)) / 6;\n\n  // 静安定用の圧力中心位置（重み付け平均）\n  const stabilityCenterOfPressure = (2 * noseStabilityCp + fin_cn * finStabilityCp) / cnTotal;\n  return {\n    stabilityCenterOfPressure // 静安定計算用の圧力中心位置 (mm)\n  };\n};\n\n// 静安定マージンを計算する関数\nexport const calculateStaticMargin = rocketParams => {\n  const {\n    centerOfGravity,\n    bodyWidth\n  } = rocketParams;\n\n  // 通常の圧力中心を計算\n  const cpData = calculateCenterOfPressure(rocketParams);\n\n  // 静安定計算用の特別な圧力中心を計算\n  const stabilityCp = calculateStabilityCenterOfPressure(rocketParams);\n\n  // 静安定マージン = (圧力中心位置 - 重心位置) / ボディ直径\n  // 通常の圧力中心を使用した場合\n  const standardStaticMargin = (cpData.centerOfPressure - centerOfGravity) / bodyWidth;\n\n  // 静安定用圧力中心を使用した場合\n  const stabilityStaticMargin = (stabilityCp.stabilityCenterOfPressure - centerOfGravity) / bodyWidth;\n  return {\n    standardStaticMargin,\n    // 通常の静安定マージン\n    stabilityStaticMargin // 静安定計算用の静安定マージン\n  };\n};\n\n// フィンダイバージェンス速度を計算する関数\nexport const calculateFinDivergenceSpeed = rocketParams => {\n  const {\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finSweepLength,\n    finThickness,\n    finMaterial\n  } = rocketParams;\n\n  // 単位をmmからmに変換\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finSweepLength_m = mmToM(finSweepLength);\n  const finThickness_m = mmToM(finThickness);\n\n  // フィン材料の特性を取得\n  const material = FIN_MATERIALS[finMaterial];\n  const G = material.G; // 横弾性係数 (Pa)\n\n  // 空気密度 (kg/m³)\n  const rho = 1.225;\n\n  // 平均コード長の計算 (m)\n  const meanChord = (finBaseWidth_m + finTipWidth_m) / 2;\n\n  // 後退角(rad)\n  const sweepbackAngle = Math.atan((finSweepLength_m + 0.5 * finTipWidth_m - 0.5 * finBaseWidth_m) * 3.14 / meanChord);\n\n  // 捻り定数J\n  const J = 0.3333 * finTipWidth_m * Math.pow(finThickness_m, 3);\n\n  // 揚力傾斜a0\n  const liftCoefficient_fin = 9 / 3.14 * Math.cos(sweepbackAngle);\n  const divSpeed = 3.14 / (2 * finHeight_m) * Math.pow(2 * G * J / (rho * Math.pow(meanChord, 2) * 0.25 * liftCoefficient_fin), 0.5);\n\n  // 現実的な範囲内に制限（極端に大きな/小さな値を防止）\n  return Math.max(20, Math.min(300, divSpeed));\n};\n\n// フィンフラッター速度を計算する関数\nexport const calculateFinFlutterSpeed = rocketParams => {\n  const {\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finThickness,\n    finMaterial\n  } = rocketParams;\n\n  // 単位をmmからmに変換\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finThickness_m = mmToM(finThickness);\n\n  // フィン材料の特性を取得\n  const material = FIN_MATERIALS[finMaterial];\n  const G = material.G; // 横弾性係数 (Pa)\n  const E = material.E; // 縦弾性係数 (Pa)\n\n  // ポアソン比（一般的な値）\n  const poissonsRatio = 0.3;\n\n  // 空気密度 (kg/m³)\n  const rho = 1.225;\n\n  // 平均コード長の計算 (m)\n  const meanChord = (finBaseWidth_m + finTipWidth_m) / 2;\n\n  // 経験的定数\n  const empiricalConstant = 3.5;\n\n  // フィンフラッター速度の計算 (m/s)\n  // V_flutter = (a * t / c^1.5) * sqrt(G * E / (12 * ρ * (1 - ν^2)))\n  const factorA = empiricalConstant * finThickness_m / Math.pow(meanChord, 1.5);\n  const factorB = Math.sqrt(G * E / (12 * rho * (1 - Math.pow(poissonsRatio, 2))));\n\n  // 計算結果が無効な場合のフォールバック\n  if (!isFinite(factorA) || !isFinite(factorB)) {\n    console.warn('フィンフラッター速度の計算に無効な値が発生しました。代替値を使用します。');\n    return 40 + mmToM(rocketParams.bodyHeight + rocketParams.noseHeight) * 120;\n  }\n  const flutterSpeed = factorA * factorB;\n\n  // 現実的な範囲内に制限（極端に大きな/小さな値を防止）\n  return Math.max(30, Math.min(400, flutterSpeed));\n};\n\n// フィンたわみ量のフォーマット関数（UI表示時に使用）\nexport const formatFinDeflection = deflection => {\n  // 15mmの場合（閾値または計算エラー）は「15mm以上」と表示\n  if (deflection === 15) {\n    return \"15mm以上\";\n  }\n\n  // 通常のたわみ量は小数点2桁までの数値を表示\n  return `${deflection.toFixed(2)}mm`;\n};\n\n// フィンダイバージェンス速度とフラッター速度の表示用フォーマット関数\nexport const formatSpeedValue = (speed, limit = 300) => {\n  // 速度値が上限を超えている場合\n  if (speed >= limit) {\n    return `${limit}+ m/s`; // 「300+ m/s」のように表示\n  }\n\n  // 通常範囲内の速度は整数で表示\n  return `${Math.round(speed)} m/s`;\n};\n\n// 高度に応じた風速を計算する関数 - 基準高度を1.5mに修正\nexport const calculateWindSpeedAtHeight = (baseWindSpeed, height, profile) => {\n  // 高度が0の場合はそのまま基準風速を返す\n  if (height <= 0) return baseWindSpeed;\n\n  // プロファイルに応じたべき指数を取得\n  const alpha = WIND_PROFILES[profile].alpha;\n\n  // べき指数が0の場合は高度に関わらず一定風速\n  if (alpha === 0) return baseWindSpeed;\n\n  // 基準高度（1.5メートル - 地上計測を想定）\n  const referenceHeight = 1.5;\n\n  // べき乗則による風速計算\n  // V(h) = V_ref * (h/h_ref)^α\n  const heightRatio = height / referenceHeight;\n  const windSpeedMultiplier = Math.pow(heightRatio, alpha);\n\n  // 風速の上限を設定（非現実的な値にならないよう制限）\n  const maxMultiplier = 3.0; // 基準風速の3倍まで\n  const actualMultiplier = Math.min(windSpeedMultiplier, maxMultiplier);\n  return baseWindSpeed * actualMultiplier;\n};\n\n// モーメント計算用のヘルパー関数 - 修正版\nconst calculateLiftMoment = (velocity, omega, flightAngle, rocketParams, sideArea, aerodynamicCenter, centerOfGravity) => {\n  const velocitySquared = Math.min(velocity * velocity, 10000);\n\n  // 迎角（姿勢角と飛行角の差）を計算\n  const angleOfAttack = omega - flightAngle;\n\n  // 迎角に比例した揚力係数（小さな角度ではsin(θ)≈θ）\n  // より大きな係数を使用してモーメントを増加\n  const liftCoefficient = 0.6 * angleOfAttack; // 係数は0.6\n\n  // 揚力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(liftCoefficient * 0.5 * 1.225 * velocitySquared * sideArea * (aerodynamicCenter - centerOfGravity) * 0.001);\n\n  // 符号の決定\n  let finalMoment;\n  if (aerodynamicCenter >= centerOfGravity && angleOfAttack < 0 || aerodynamicCenter < centerOfGravity && angleOfAttack >= 0) {\n    finalMoment = -momentMagnitude; // マイナス\n  } else {\n    finalMoment = momentMagnitude; // プラス\n  }\n\n  // 最小モーメント保証 (非常に小さな値になるのを防ぐ)\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n\n  // 角度が大きすぎる場合はモーメントを増加\n  if (Math.abs(angleOfAttack) > 0.5) {\n    // 約28.6度以上\n    return finalMoment * 1.2; // モーメントを20%増加\n  }\n  return finalMoment;\n};\nconst calculateDragMoment = (velocity, omega, flightAngle, rocketParams, sideArea, aerodynamicCenter, centerOfGravity) => {\n  const velocitySquared = Math.min(velocity * velocity, 10000);\n\n  // 迎角を計算\n  const angleOfAttack = omega - flightAngle;\n\n  // 迎角の二乗に比例した抗力増加\n  const dragCoefficient = 0.01 * Math.pow(angleOfAttack, 2) - 0.02 * angleOfAttack + 0.63;\n\n  // 抗力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(dragCoefficient * 0.5 * 1.225 * velocitySquared * sideArea * (aerodynamicCenter - centerOfGravity) * 0.001);\n\n  // 符号の決定\n  let finalMoment;\n  if (aerodynamicCenter >= centerOfGravity && angleOfAttack < 0 || aerodynamicCenter < centerOfGravity && angleOfAttack >= 0) {\n    finalMoment = -momentMagnitude; // マイナス\n  } else {\n    finalMoment = momentMagnitude; // プラス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  return finalMoment;\n};\nconst calculateWindMoment = (noseHeight, bodyDiameter, bodyHeight, windSpeed, omega, totalFinArea, centerOfPressure, centerOfGravity) => {\n  // 風速に上限を設定\n  const safeWindSpeed = Math.max(-25, Math.min(25, windSpeed));\n\n  // 風速によりフィンが受ける力\n  const Dwf = 9.81 * 0.05 * Math.pow(safeWindSpeed, 2) * totalFinArea;\n\n  // 風速によりボディが受ける力\n  const Dwb = 0.23 * 0.5 * 1.225 * Math.pow(safeWindSpeed, 2) * bodyDiameter * (bodyHeight + noseHeight) / 1000000;\n\n  // 安全なコサイン計算\n  const cosAngle = Math.cos(omega);\n\n  // 風モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs((Dwf + Dwb) * cosAngle * (centerOfPressure - centerOfGravity) * 0.001);\n\n  // 符号の決定\n  let finalMoment;\n  if (centerOfPressure >= centerOfGravity && windSpeed < 0 || centerOfPressure < centerOfGravity && windSpeed >= 0) {\n    finalMoment = momentMagnitude; // プラス\n  } else {\n    finalMoment = -momentMagnitude; // マイナス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  return finalMoment;\n};\n\n// 風見効果による角度制限関数\nconst applyWindDirectionAngleLimit = (omega, windSpeed) => {\n  // 風速が非常に小さい場合は制限なし\n  if (Math.abs(windSpeed) < 0.5) return omega;\n\n  // 風向きに応じた制限角度（ラジアン）\n  // 風が右から左（負の風速）なら -90度に制限（風上である右向き）\n  // 風が左から右（正の風速）なら +90度に制限（風上である左向き）\n  const limitAngle = Math.sign(windSpeed) * Math.PI / 2;\n\n  // 風上に向かっているかどうか\n  // 風が右から左（負の風速）で機体が右向き（負の角度）に傾いている場合\n  // または、風が左から右（正の風速）で機体が左向き（正の角度）に傾いている場合\n  const isMovingUpwind = windSpeed < 0 && omega < 0 || windSpeed > 0 && omega > 0;\n\n  // 角度制限を適用（風上へ向かう場合のみ）\n  if (isMovingUpwind) {\n    // 角度が制限値を超えているかチェック\n    if (windSpeed < 0 && omega < limitAngle || windSpeed > 0 && omega > limitAngle) {\n      // 制限角度に制限\n      return limitAngle;\n    }\n  }\n\n  // それ以外の場合は元の角度をそのまま返す\n  return omega;\n};\n\n// 推力モーメント計算関数\nconst calculateThrustMoment = (thrust, centerOfGravity, omega, flightAngle, rocketParams) => {\n  const {\n    noseHeight,\n    bodyHeight\n  } = rocketParams;\n\n  // 迎角を計算\n  const angleOfAttack = omega - flightAngle;\n\n  // 推力発生位置（ロケットの最後尾）\n  const thrustPosition = noseHeight + bodyHeight;\n\n  // 推力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(thrust * Math.sin(angleOfAttack) * Math.cos(angleOfAttack) * (thrustPosition - centerOfGravity) * 0.001);\n\n  // 符号の決定\n  let finalMoment;\n  if (thrustPosition >= centerOfGravity && angleOfAttack < 0 || thrustPosition < centerOfGravity && angleOfAttack >= 0) {\n    finalMoment = momentMagnitude; // プラス\n  } else {\n    finalMoment = -momentMagnitude; // マイナス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  return finalMoment;\n};\n\n// フィンのたわみ量計算\nconst calculateFinDeflection = (velocity, material, finParams, angleChangePerDt2) => {\n  const {\n    finHeight,\n    finBaseWidth,\n    finTipWidth,\n    finThickness,\n    finSweepLength\n  } = finParams;\n  const {\n    E\n  } = material;\n\n  // 速度0の場合は早期リターン\n  if (Math.abs(velocity) < 0.001) return 0;\n\n  // finThicknessが小数の場合も適切に扱えるように\n  const safeFinThickness = Number(finThickness) || 2.0; // デフォルト値として2.0mm\n\n  // 安全な角度変化量を確保\n  const safeAngleChange = Math.max(-0.5, Math.min(0.5, angleChangePerDt2));\n\n  // 安全な速度（極端に大きな値を制限）\n  const safeVelocity = Math.min(velocity, 300);\n  try {\n    // フィンの面積（m^2）\n    const finArea = (finBaseWidth + finTipWidth) * 0.001 * (finHeight * 0.001) / 2;\n\n    // テーパー比（無次元）- 分母0防止\n    let taperRatio = 0;\n    if (finHeight > 0) {\n      taperRatio = (finBaseWidth * 0.001 - finTipWidth * 0.001) / (finHeight * 0.001);\n      // 極端な値の制限\n      taperRatio = Math.max(-0.9, Math.min(0.9, taperRatio));\n    }\n\n    // 後退角（ラジアン）\n    const sweepAngle = Math.atan((finSweepLength * 0.001 + 0.5 * finTipWidth * 0.001 - 0.5 * finBaseWidth * 0.001) * Math.PI / (finHeight * 0.001));\n\n    // 断面二次モーメント（近似）- 分母0防止\n    let I = 0;\n    if (finTipWidth > 0 && safeFinThickness > 0) {\n      I = finTipWidth * 0.001 * Math.pow(safeFinThickness * 0.001, 3) / 12;\n    }\n\n    // I値が極端に小さい（または0）の場合は安全値を設定\n    if (I < 1e-12) {\n      I = 1e-12; // 極小値を設定して分母0を防止\n    }\n\n    // 風圧による力（F）- 速度の二乗に比例\n    const windForce = 9.81 * 0.05 * safeVelocity * safeVelocity * Math.sin(safeAngleChange) * finArea;\n\n    // 単位長さあたりの風圧による力\n    const unitlengthWindForce = windForce / Math.max(0.001, finHeight * 0.001);\n\n    // たわみ量計算（mm）\n    const deflectionFactor = 1 / (1 - taperRatio);\n    const rawDeflection = unitlengthWindForce * Math.pow(finHeight * 0.001, 4) * Math.cos(sweepAngle) / (8 * E * I) * deflectionFactor;\n\n    // NaNチェック\n    if (isNaN(rawDeflection)) {\n      console.warn('フィンたわみ量計算でNaNが発生しました');\n      return 15; // NaNの場合は閾値を返す（表示時に変換）\n    }\n\n    // たわみ量の絶対値が15mmを超える場合は15に制限\n    if (Math.abs(rawDeflection) > 15) {\n      // 15mmを超えるたわみ → 15を返す（表示時に「15mm以上」に変換）\n      return 15;\n    }\n\n    // 通常範囲内のたわみ量\n    return rawDeflection;\n  } catch (error) {\n    console.error(\"Fin deflection calculation error:\", error);\n    return 15; // エラー時は閾値を返す（表示時に「15mm以上」に変換）\n  }\n};\n\n// 物理計算 (calculateFlightPath関数の完全実装)\nexport const calculateFlightPath = (rocketParams, angle, windSpeed, windProfile, config) => {\n  // 角度変化を記録するための変数\n  let prevOmega = angle * Math.PI / 180; // 前フレームの角度（初期値は発射角度）\n  let currentMaxAngleChange = 0; // 直接更新用の最大角度変化量\n  const dt = 0.02;\n  const dt2 = ANGLE_RESPONSE_DT; // 角度応答時間\n  const mass_kg = gToKg(rocketParams.weight);\n  const thrustData = MOTOR_THRUST_DATA[rocketParams.selectedMotor];\n  const launchRailLength = PHYSICAL_CONSTANTS.launchRailLength; // 発射台の長さ (m)\n  const MAX_TIME = 20; // 最大シミュレーション時間 (s)\n\n  // ロケットの物理パラメータ\n  const bodyDiameter = mmToM(rocketParams.bodyWidth); // ロケット直径 (m)\n  const bodyRadius = bodyDiameter / 2; // ロケット半径 (m)\n  const bodyLength = mmToM(rocketParams.bodyHeight + rocketParams.noseHeight); // ロケット全長 (m)\n  const finwidth_m = mmToM(rocketParams.finHeight); // フィン幅\n  const finThickness_m = mmToM(rocketParams.finThickness);\n  const PI = Math.PI;\n\n  // 慣性モーメントの計算 (I = 0.25*m*r^2 + 0.833*m*l^2)\n  const momentOfInertia = 0.25 * mass_kg * bodyRadius * bodyRadius + 0.833 * mass_kg * bodyLength * bodyLength;\n\n  // ノーズ形状に基づく抗力係数\n  const noseCd = NOSE_SHAPES[rocketParams.noseShape].cd;\n\n  // フィン材料特性\n  const finMaterial = FIN_MATERIALS[rocketParams.finMaterial];\n\n  // パラシュート関連の定数\n  const thrustEndTime = thrustData.length * dt;\n  const parachuteDelay = parseInt(rocketParams.selectedMotor.split('-')[1]);\n  const parachuteDeployTime = 1.0;\n  const parachuteEjectionTime = thrustEndTime + parachuteDelay;\n  const parachuteActiveTime = parachuteEjectionTime + parachuteDeployTime;\n  const parachuteDiameter = mmToM(parseInt(rocketParams.selectedParachute.slice(1))); // φ180 -> 180mm -> 0.18m\n\n  // 新しい計算 - 投影面積と圧力中心の計算\n  const projectedAreas = calculateProjectedArea(rocketParams);\n  const centerOfPressure = calculateCenterOfPressure(rocketParams);\n  const aerodynamicCenter = calculateAerodynamicCenter(rocketParams);\n  const stabilityCenterOfPressure = calculateStabilityCenterOfPressure(rocketParams);\n\n  // 体積計算\n  const volumes = calculateVolume(rocketParams);\n\n  // 静安定マージン計算\n  const staticMargins = calculateStaticMargin(rocketParams);\n\n  // 状態変数の初期化\n  let time = 0;\n  let x = 0; // メートル単位\n  let y = 0; // メートル単位\n  let vx = 0;\n  let vy = 0;\n  let prev_vx = 0;\n  let prev_vy = 0;\n  let omega = angle * Math.PI / 180; // 初期角度（ラジアン）\n  let angularVelocity = 0; // 角速度\n  let angularAcceleration = 0; // 角加速度\n  let data = [];\n  let isParachuteEjected = false;\n  let isParachuteActive = false;\n  let parachuteDeploymentProgress = 0;\n  let finDeflection = 0; // フィンのたわみ量（mm）\n\n  // 姿勢安定性チェック用の変数を追加\n  let maxAngleChangePerDt2 = 0; // dt2時間あたりの最大角度変化量\n  let isAngleStableOK = true; // 姿勢安定性の判定\n  let thrustEndFlag = false; // 推力終了フラグ\n  const initialOmegaDegrees = angle; // 初期角度（度）\n\n  // 角度計算用変数\n  let stepCounter = 0;\n  let totalTorque = 0;\n  let avgThrustForTorque = 0;\n  let thrustSamplesCount = 0;\n  let angleChangePerDt2 = 0; // dt2時間あたりの角度変化量 (ν)\n\n  // 重力加速度\n  const g = 9.81; // m/s²\n\n  // 記録用変数\n  let maxHeight = 0;\n  let maxSpeed = 0;\n  let maxDistance = 0; // 最大水平距離を記録\n  let maxFinDeflection = 0; // 最大フィンたわみ量\n\n  // キーポイント記録\n  let keyPoints = {\n    thrustEnd: {\n      time: 0,\n      height: 0,\n      speed: 0\n    },\n    maxHeight: {\n      time: 0,\n      height: 0,\n      speed: 0\n    },\n    parachuteEjection: {\n      time: 0,\n      height: 0,\n      speed: 0\n    },\n    parachuteActive: {\n      time: 0,\n      height: 0,\n      speed: 0\n    }\n  };\n\n  // シミュレーションループ\n  while ((y >= 0 || time < 0.1) && time < MAX_TIME) {\n    // 前回の速度を保存\n    prev_vx = vx;\n    prev_vy = vy;\n\n    // パラシュート状態の更新\n    if (!isParachuteEjected && time >= parachuteEjectionTime) {\n      isParachuteEjected = true;\n      keyPoints.parachuteEjection = {\n        time,\n        height: y,\n        speed: vy\n      };\n    }\n    if (isParachuteEjected && !isParachuteActive) {\n      parachuteDeploymentProgress = Math.min(1, (time - parachuteEjectionTime) / parachuteDeployTime);\n    }\n    if (!isParachuteActive && time >= parachuteActiveTime) {\n      isParachuteActive = true;\n      parachuteDeploymentProgress = 1.0;\n\n      // パラシュート展開時は速度を90%減少\n      vx = vx * 0.1;\n      vy = vy * 0.1;\n      keyPoints.parachuteActive = {\n        time,\n        height: y,\n        speed: vy\n      };\n    }\n    const distanceFromStart = Math.sqrt(x * x + y * y);\n    const onLaunchRail = distanceFromStart < launchRailLength;\n\n    // 速度の大きさ\n    const velocity = Math.sqrt(prev_vx * prev_vx + prev_vy * prev_vy);\n\n    // 現在の高度に基づく有効風速を計算\n    const effectiveWindSpeed = calculateWindSpeedAtHeight(windSpeed, y, windProfile);\n\n    // 力と加速度の初期化\n    let ax = 0;\n    let ay = -g;\n    let torque = 0; // トルク\n    let Fx = 0;\n    let Fy = 0;\n    let thrust = 0;\n\n    // 特定の角度への対応\n    const angleAdjustment = Math.abs(angle) === 4 || Math.abs(angle) === 18 ? 0.01 : 0;\n    const adjustedOmega = omega + angleAdjustment * (angle < 0 ? -1 : 1);\n\n    // フィンのたわみ量計算\n    if (velocity > 5.0) {\n      const finParams = {\n        finHeight: rocketParams.finHeight,\n        finBaseWidth: rocketParams.finBaseWidth,\n        finTipWidth: rocketParams.finTipWidth,\n        finThickness: rocketParams.finThickness,\n        finSweepLength: rocketParams.finSweepLength\n      };\n      finDeflection = calculateFinDeflection(velocity, finMaterial, finParams, angleChangePerDt2);\n\n      // 最大フィンたわみ量を更新\n      if (finDeflection > maxFinDeflection) {\n        maxFinDeflection = finDeflection;\n      }\n    } else {\n      finDeflection = 0;\n    }\n\n    // パラシュートフェーズ\n    if (isParachuteActive) {\n      // パラシュートの抗力計算\n      const Cd = 0.775; // パラシュートの抗力係数\n      const rho = 1.225; // 空気密度 (kg/m³)\n      const Area = PI * Math.pow(parachuteDiameter / 2, 2);\n      const Dp = 0.5 * Cd * rho * velocity * velocity * Area;\n\n      // 速度方向への抗力\n      if (velocity > 0.001) {\n        Fx = -Dp * (prev_vx / velocity);\n        Fy = -Dp * (prev_vy / velocity);\n      }\n\n      // 横風の影響を追加（高度に応じた風速を使用）\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = parachuteDiameter * parachuteDiameter * 0.785; // パラシュートの投影面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      Fx -= Dw; // 横風の影響を追加\n\n      // 重力の追加\n      Fy -= mass_kg * g;\n\n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n\n      // トルク計算 - パラシュート展開後は発射角度を維持する\n      const initialOmega = angle * Math.PI / 180;\n      if (Math.abs(adjustedOmega - initialOmega) > 0.01) {\n        // 簡易的なトルク - 後でより正確な計算に置き換え\n        torque = (initialOmega - adjustedOmega) * 0.001;\n      }\n    } else if (isParachuteEjected && !isParachuteActive) {\n      // パラシュート展開中\n      Fy = -mass_kg * g;\n\n      // 軽い空気抵抗\n      if (velocity > 0.001) {\n        const dragCoefficient = 0.1;\n        Fx = -dragCoefficient * prev_vx;\n        Fy -= dragCoefficient * prev_vy;\n      }\n\n      // 横風の影響を小さく追加（高度に応じた風速を使用）\n      const rho = 1.225; // 空気密度\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = bodyDiameter * bodyLength * 0.5; // 半分展開時の面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      Fx -= Dw * 0.5; // 展開中なので横風の影響を半分に\n\n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n\n      // トルク計算 - パラシュート展開中も発射角度に強く引っ張られる\n      const initialOmega = angle * Math.PI / 180;\n      // 簡易的なトルク - 後でより正確な計算に置き換え\n      torque = (initialOmega - adjustedOmega) * 0.0005;\n    } else {\n      // 通常飛行フェーズ\n\n      // ロケットの抗力計算 - ノーズ形状に基づく抗力係数を使用\n      const Cd = noseCd;\n      const rho = 1.225; // 空気密度\n      const Area = PI * Math.pow(bodyDiameter / 2, 2) + finwidth_m * finThickness_m * 4;\n      const Dt = 0.5 * Cd * rho * velocity * velocity * Area;\n\n      // 横風の抗力計算（高度に応じた風速を使用）\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = bodyDiameter * bodyLength; // ロケットの側面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      if (time < thrustEndTime) {\n        // エンジン推力フェーズ\n        const thrustIndex = Math.min(Math.floor(time / dt), thrustData.length - 1);\n        thrust = thrustData[thrustIndex];\n\n        // 推力サンプルをトルク計算用に累積\n        avgThrustForTorque += thrust;\n        thrustSamplesCount++;\n        if (onLaunchRail) {\n          // 発射台上での運動\n          if (angle === 0) {\n            // 垂直発射\n            Fy = thrust - mass_kg * g;\n            Fx = -Dw; // 横風の影響のみ\n          } else {\n            // 角度付き発射 (修正した式)\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g;\n            Fx = thrust * Math.sin(adjustedOmega) - Dw; // 横風の影響を追加\n          }\n\n          // 発射台上は角度固定\n          torque = 0;\n        } else {\n          // 自由飛行（推力あり）\n          if (velocity > 0.001) {\n            // 修正: 推力と抗力の分解方法を修正\n            // T*sinθ - Dt*sinθ - Dw, T*cosθ - m*g - Dt*cosθ\n            Fx = thrust * Math.sin(adjustedOmega) - Dt * Math.sin(adjustedOmega) - Dw;\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g - Dt * Math.cos(adjustedOmega);\n          } else {\n            // 速度がほぼゼロの場合\n            Fx = thrust * Math.sin(adjustedOmega) - Dw;\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g;\n          }\n\n          // トルク計算 - 推力フェーズ\n          if (velocity > 1.0) {\n            const flightAngle = Math.atan2(prev_vx, prev_vy);\n            try {\n              // 新しいモーメント計算関数を使用\n              const ML = calculateLiftMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n              const MD = calculateDragMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n              const MW = calculateWindMoment(rocketParams.noseHeight, bodyDiameter, rocketParams.bodyHeight, effectiveWindSpeed, adjustedOmega, projectedAreas.totalFinArea, centerOfPressure.centerOfPressure, rocketParams.centerOfGravity);\n              const MT = calculateThrustMoment(thrust, rocketParams.centerOfGravity, adjustedOmega, flightAngle, rocketParams);\n\n              // トルク値の検証 - 無限大や非数値をチェック\n              if (!isFinite(ML) || isNaN(ML)) torque += 0;else if (!isFinite(MD) || isNaN(MD)) torque += 0;else if (!isFinite(MW) || isNaN(MW)) torque += 0;else if (!isFinite(MT) || isNaN(MT)) torque += 0;else {\n                // 合計トルク - 上限設定を追加\n                const rawTorque = ML + MD + MW + MT;\n\n                // トルク値が小さすぎる問題を解決するために、最小トルク閾値を設定\n                const MIN_TORQUE_THRESHOLD = 0.0001;\n\n                // トルクの絶対値が閾値以下の場合、符号を保持して最小値を使用\n                if (Math.abs(rawTorque) > 0 && Math.abs(rawTorque) < MIN_TORQUE_THRESHOLD) {\n                  torque = Math.sign(rawTorque) * MIN_TORQUE_THRESHOLD;\n                } else {\n                  // 通常のトルク制限\n                  torque = Math.max(-1.0, Math.min(1.0, rawTorque));\n                }\n\n                // デバッグ用ログ - トルク計算の詳細を表示\n                if (Math.abs(torque) > 0.001 || Math.abs(ML) > 0.001 || Math.abs(MD) > 0.001 || Math.abs(MW) > 0.001 || Math.abs(MT) > 0.001) {\n                  console.log(`Thrust Torque components (t=${time.toFixed(2)}): ML=${ML.toFixed(6)}, MD=${MD.toFixed(6)}, MW=${MW.toFixed(6)}, MT=${MT.toFixed(6)}, Total=${torque.toFixed(6)}`);\n                }\n              }\n\n              // ±4°と±18°の場合のトルク補正\n              if (Math.abs(angle) === 4 || Math.abs(angle) === 18) {\n                torque *= 1.2; // 20%増加\n              }\n            } catch (error) {\n              // エラーが発生した場合はトルクをゼロにして続行\n              console.error('Torque calculation error:', error);\n              torque = 0;\n            }\n          }\n        }\n      } else {\n        // 推力終了時のフラグを設定\n        if (!thrustEndFlag) {\n          thrustEndFlag = true;\n          keyPoints.thrustEnd = {\n            time,\n            height: y,\n            speed: vy\n          };\n        }\n\n        // 慣性飛行（推力なし）- ここでは推力T=0\n\n        if (velocity > 0.001) {\n          // 修正: Fx = -Dt*sinθ - Dw, Fy = -m*g - Dt*cosθ\n          Fx = -Dt * Math.sin(adjustedOmega) - Dw;\n          Fy = -mass_kg * g - Dt * Math.cos(adjustedOmega);\n        } else {\n          Fx = -Dw;\n          Fy = -mass_kg * g;\n        }\n\n        // トルク計算 - 慣性飛行フェーズ\n        if (velocity > 0.5) {\n          const flightAngle = Math.atan2(prev_vx, prev_vy);\n\n          // 新しいモーメント計算メソッドを使用\n          try {\n            // 新しいモーメント計算関数を使用\n            const ML = calculateLiftMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n            const MD = calculateDragMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n            const MW = calculateWindMoment(rocketParams.noseHeight, bodyDiameter, rocketParams.bodyHeight, effectiveWindSpeed, adjustedOmega, projectedAreas.totalFinArea, centerOfPressure.centerOfPressure, rocketParams.centerOfGravity);\n            // 推力ゼロなのでMTは0\n\n            // 合計トルク\n            const rawTorque = ML + MD + MW;\n\n            // トルク値が小さすぎる問題を解決するために、最小トルク閾値を設定\n            const MIN_TORQUE_THRESHOLD = 0.0001;\n\n            // トルクの絶対値が閾値以下の場合、符号を保持して最小値を使用\n            if (Math.abs(rawTorque) > 0 && Math.abs(rawTorque) < MIN_TORQUE_THRESHOLD) {\n              torque = Math.sign(rawTorque) * MIN_TORQUE_THRESHOLD;\n            } else {\n              // 通常のトルク制限\n              torque = Math.max(-1.0, Math.min(1.0, rawTorque));\n            }\n\n            // デバッグ用ログ - トルク計算の詳細を表示\n            if (Math.abs(torque) > 0.001 || Math.abs(ML) > 0.001 || Math.abs(MD) > 0.001 || Math.abs(MW) > 0.001) {\n              console.log(`Inertial Torque components (t=${time.toFixed(2)}): ML=${ML.toFixed(6)}, MD=${MD.toFixed(6)}, MW=${MW.toFixed(6)}, Total=${torque.toFixed(6)}`);\n            }\n          } catch (error) {\n            console.error('Torque calculation error:', error);\n            torque = 0;\n          }\n\n          // ±4°と±18°の場合のトルク補正\n          if (Math.abs(angle) === 4 || Math.abs(angle) === 18) {\n            torque *= 1.2; // 20%増加\n          }\n        }\n      }\n\n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n    }\n\n    // トルクの累積\n    totalTorque += torque;\n    stepCounter++;\n\n    // 角度の更新（dt2間隔で）\n    if (stepCounter >= ANGLE_STEPS_PER_UPDATE) {\n      try {\n        // トルクの平均を計算\n        const avgTorque = totalTorque; // const avgTorque = totalTorque / stepCounter???????\n\n        // トルクが非数値または無限大の場合はゼロにリセット\n        const safeAvgTorque = isFinite(avgTorque) && !isNaN(avgTorque) ? avgTorque : 0;\n\n        // 最小トルク保証 - これにより姿勢変化が確実に発生する\n        const MIN_TORQUE = 0.00001;\n        let effectiveTorque = safeAvgTorque;\n        if (Math.abs(safeAvgTorque) > 0 && Math.abs(safeAvgTorque) < MIN_TORQUE) {\n          effectiveTorque = Math.sign(safeAvgTorque) * MIN_TORQUE;\n        }\n\n        // トルク計算のデバッグ出力\n        if (Math.abs(effectiveTorque) > 0.001) {\n          console.log(`Torque calculation (t=${time.toFixed(2)}): avgTorque=${safeAvgTorque.toFixed(6)}, effectiveTorque=${effectiveTorque.toFixed(6)}, momentOfInertia=${momentOfInertia.toFixed(6)}`);\n        }\n\n        // 角加速度の計算: α = M/I\n        angularAcceleration = effectiveTorque / momentOfInertia;\n\n        // 角速度の更新: ω = ω0 + α*dt2\n        const oldAngularVelocity = angularVelocity;\n        angularVelocity = angularVelocity + angularAcceleration * dt2;\n\n        // 角速度に上限を設定\n        angularVelocity = Math.max(-3, Math.min(3, angularVelocity));\n\n        // 角度変化の計算: ν = ω*dt2\n        angleChangePerDt2 = angularVelocity * dt2;\n\n        // 最小角度変化保証 - 非常に小さな値でも角度更新を保証\n        const MIN_ANGLE_CHANGE_PER_DT2 = 0.001; // 角度変化を強調するために増加（0.0001→0.001）\n\n        if (Math.abs(angleChangePerDt2) > 0 && Math.abs(angleChangePerDt2) < MIN_ANGLE_CHANGE_PER_DT2) {\n          angleChangePerDt2 = Math.sign(angleChangePerDt2) * MIN_ANGLE_CHANGE_PER_DT2;\n        }\n\n        // 角度変化のデバッグ出力\n        if (Math.abs(oldAngularVelocity - angularVelocity) > 0.001 || Math.abs(angleChangePerDt2) > 0.001) {\n          console.log(`Angle change calculation (t=${time.toFixed(2)}): angularAcceleration=${angularAcceleration.toFixed(6)}, angularVelocity=${angularVelocity.toFixed(6)}, angleChangePerDt2=${angleChangePerDt2.toFixed(6)}`);\n        }\n\n        // 姿勢安定性チェック（パラシュート展開前かつ推力終了後の慣性飛行中）\n        if (!isParachuteEjected && thrustEndFlag) {\n          // dt2時間あたりの角度変化量（度数法）\n          const angleChangePerDt2Degrees = angleChangePerDt2 * 180 / Math.PI;\n\n          // 最大角度変化量を更新\n          if (Math.abs(angleChangePerDt2Degrees) > Math.abs(maxAngleChangePerDt2)) {\n            maxAngleChangePerDt2 = angleChangePerDt2Degrees;\n          }\n\n          // 角度変化量が±10°を超える場合にNG判定（0.2秒間の変化量）\n          if (Math.abs(angleChangePerDt2Degrees) > 10) {\n            isAngleStableOK = false;\n          }\n        }\n\n        // カウンターとトルク累積のリセット\n        stepCounter = 0;\n        totalTorque = 0;\n        avgThrustForTorque = 0;\n        thrustSamplesCount = 0;\n      } catch (error) {\n        // エラーが発生した場合でも安全に処理\n        console.error('Angle update error:', error);\n        stepCounter = 0;\n        totalTorque = 0;\n        avgThrustForTorque = 0;\n        thrustSamplesCount = 0;\n      }\n    }\n\n    // 物理ベースの角度更新を強化 - この部分は常に適用される\n    // 角度の更新 - angleChangePerDt2の値を確実に反映\n    const physicsBasedAngleChange = angleChangePerDt2 / ANGLE_STEPS_PER_UPDATE;\n\n    // 物理ベースの変化が非常に小さい場合の最小変化量を設定\n    const MIN_ANGLE_CHANGE = 0.0001; // ラジアン単位での最小角度変化\n\n    // 物理ベースの姿勢変化を適用\n    if (PHYSICAL_ATTITUDE_CONTROL) {\n      if (Math.abs(physicsBasedAngleChange) > 0 && Math.abs(physicsBasedAngleChange) < MIN_ANGLE_CHANGE) {\n        // 変化量が小さすぎる場合は適切な最小値を使用\n        omega += Math.sign(physicsBasedAngleChange) * MIN_ANGLE_CHANGE;\n      } else {\n        // 通常の物理ベースの角度更新\n        omega += physicsBasedAngleChange;\n      }\n\n      // 角度変化のデバッグ出力 - 実際に何が起きているかを確認\n      if (Math.abs(physicsBasedAngleChange) > 0.001) {\n        console.log(`Applied physics angle change (t=${time.toFixed(2)}): ${physicsBasedAngleChange.toFixed(6)}, new omega=${omega.toFixed(6)}`);\n      }\n    }\n\n    // 拡張姿勢制御ロジック - 風見効果など\n    if (ENHANCED_ATTITUDE_CONTROL) {\n      // 発射台を離れた後かつパラシュート展開前\n      if (!onLaunchRail && !isParachuteEjected) {\n        // 速度ベクトルの方向（飛行角）\n        const flightAngle = Math.atan2(vx, vy);\n\n        // 推力フェーズと慣性飛行フェーズで完全に分ける\n        if (thrustEndFlag) {\n          //===========================================\n          // 慣性飛行中 - 風見効果を無効化\n          //===========================================\n\n          // 目標姿勢角は常に速度方向（風の影響を受けない）\n          const targetOmega = flightAngle;\n\n          // 姿勢角変化のスピード係数 - 非常に小さな値\n          const adjustRate = Math.min(0.05, 0.002 * velocity);\n\n          // 姿勢角を目標角に近づける（緩やかに）\n          const newOmega = omega * (1.0 - adjustRate) + targetOmega * adjustRate;\n\n          // 変化量の制限も小さめ\n          // 変化量の制限を大きくする - 約11.5度/フレーム\n          const maxChange = 0.2;\n          if (Math.abs(newOmega - omega) > maxChange) {\n            omega += Math.sign(newOmega - omega) * maxChange;\n          } else {\n            omega = newOmega;\n          }\n\n          // デバッグ用ログ - 拡張姿勢制御の適用を確認\n          if (Math.abs(newOmega - omega) > 0.01) {\n            console.log(`Applied enhanced attitude control (inertial): targetOmega=${targetOmega.toFixed(6)}, newOmega=${newOmega.toFixed(6)}`);\n          }\n        } else {\n          //===========================================\n          // 推力飛行中 - 風見効果を適用\n          //===========================================\n\n          // 風向きベクトル\n          const windAngle = effectiveWindSpeed > 0 ? 0 : Math.PI; // 風が左から右:0度、右から左:180度\n\n          // 風向きに対する垂直方向 (±90度)\n          const perpendicularToWind1 = windAngle + Math.PI / 2; // +90度\n          const perpendicularToWind2 = windAngle - Math.PI / 2; // -90度\n\n          // 目標姿勢角の決定\n          let targetOmega;\n          if (Math.abs(effectiveWindSpeed) < 0.5) {\n            // 風が弱い場合は速度方向に合わせる\n            targetOmega = flightAngle;\n          } else {\n            // 風が強い場合、風向きも考慮する\n\n            // 風上に向かっているか判定 - 風向きと速度が「逆」のとき風上\n            const isMovingUpwind = effectiveWindSpeed < 0 && vx > 0 || effectiveWindSpeed > 0 && vx < 0;\n            if (isMovingUpwind) {\n              // 風上に向かう場合は風に対して垂直方向を超えない\n              if (effectiveWindSpeed < 0) {\n                // 右からの風の場合、-90度まで（右向き）\n                targetOmega = Math.max(flightAngle, perpendicularToWind2);\n              } else {\n                // 左からの風の場合、+90度まで（左向き）\n                targetOmega = Math.min(flightAngle, perpendicularToWind1);\n              }\n            } else {\n              // 風下に向かう場合は直接速度方向\n              targetOmega = flightAngle;\n            }\n          }\n\n          // 推力飛行中の姿勢角変化のスピード係数（現状維持）\n          const adjustRate = Math.min(0.05, 0.002 * velocity);\n\n          // 風速に応じた調整\n          const windFactor = Math.min(0.8, Math.abs(effectiveWindSpeed) / 6.0);\n          const finalAdjustRate = adjustRate * (1.0 + windFactor);\n\n          // 姿勢角を目標角に近づける\n          const newOmega = omega * (1.0 - finalAdjustRate) + targetOmega * finalAdjustRate;\n\n          // 変化量の制限を大きくする - 約11.5度/フレーム\n          const maxChange = 0.2;\n          if (Math.abs(newOmega - omega) > maxChange) {\n            omega += Math.sign(newOmega - omega) * maxChange;\n          } else {\n            omega = newOmega;\n          }\n\n          // デバッグ用ログ - 拡張姿勢制御の適用を確認\n          if (Math.abs(newOmega - omega) > 0.01) {\n            console.log(`Applied enhanced attitude control (thrust): targetOmega=${targetOmega.toFixed(6)}, newOmega=${newOmega.toFixed(6)}`);\n          }\n        }\n      }\n    }\n\n    // 速度の更新\n    vx = vx + ax * dt;\n    vy = vy + ay * dt;\n\n    // 速度制限（最大100m/s）\n    const MAX_SPEED = 100; // m/s\n    const currentSpeed = Math.sqrt(vx * vx + vy * vy);\n    if (currentSpeed > MAX_SPEED) {\n      const factor = MAX_SPEED / currentSpeed;\n      vx *= factor;\n      vy *= factor;\n    }\n\n    // 角速度の制限\n    const MAX_ANGULAR_VELOCITY = 5; // rad/s\n    angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, angularVelocity));\n\n    // 位置の更新\n    if (onLaunchRail) {\n      // 発射台上の動き\n      if (angle === 0) {\n        // 垂直発射\n        x = 0;\n        y = y + vy * dt;\n      } else {\n        // 角度付き発射\n        const railDistance = Math.min(distanceFromStart + velocity * dt, launchRailLength);\n        x = railDistance * Math.sin(omega);\n        y = railDistance * Math.cos(omega);\n      }\n    } else {\n      // 自由飛行の位置更新\n      x = x + vx * dt;\n      y = y + vy * dt;\n    }\n\n    // 最高高度と最高速度の更新\n    if (y > maxHeight) {\n      maxHeight = y;\n      keyPoints.maxHeight = {\n        time,\n        height: maxHeight,\n        speed: vy\n      };\n    }\n    if (currentSpeed > maxSpeed) {\n      maxSpeed = currentSpeed;\n    }\n\n    // 最大水平距離の更新\n    if (Math.abs(x) > maxDistance) {\n      maxDistance = Math.abs(x);\n    }\n\n    // データの記録\n    data.push({\n      time,\n      physicsX: x,\n      // 物理座標系でのx（メートル単位）\n      physicsY: y,\n      // 物理座標系でのy（メートル単位）\n      height: y,\n      // メートル単位\n      vx: vx,\n      vy: vy,\n      ax: ax,\n      ay: ay,\n      speedMagnitude: Math.sqrt(vx * vx + vy * vy),\n      accelerationMagnitude: Math.sqrt(ax * ax + ay * ay),\n      angularVelocity,\n      angularAcceleration,\n      isParachuteEjected,\n      isParachuteActive,\n      parachuteDeploymentProgress,\n      omega,\n      torque,\n      angleChangePerDt2,\n      horizontalDistance: Math.abs(x),\n      // 水平距離の絶対値を追加\n      finDeflection,\n      // フィンのたわみ量を追加\n      angleDeviationDegrees: omega * 180 / Math.PI - initialOmegaDegrees,\n      // 初期角度からの偏差を追加\n      effectiveWindSpeed // 実効風速を記録\n    });\n    time += dt;\n  }\n  console.log(`シミュレーション完了: 最高高度=${maxHeight.toFixed(2)}m, 最高速度=${maxSpeed.toFixed(2)}m/s, 最大水平距離=${maxDistance.toFixed(2)}m`);\n  console.log(`推力終了時 (${keyPoints.thrustEnd.time.toFixed(2)}s): 高度=${keyPoints.thrustEnd.height.toFixed(2)}m, 速度=${keyPoints.thrustEnd.speed.toFixed(2)}m/s`);\n  console.log(`最高点 (${keyPoints.maxHeight.time.toFixed(2)}s): 高度=${keyPoints.maxHeight.height.toFixed(2)}m, 速度=${keyPoints.maxHeight.speed.toFixed(2)}m/s`);\n  console.log(`最大フィンたわみ量: ${maxFinDeflection.toFixed(4)}mm`);\n  console.log(`最大角度変化量/dt2: ${maxAngleChangePerDt2.toFixed(2)}°`);\n  console.log(`姿勢安定性判定: ${isAngleStableOK ? 'OK' : 'NG'}`);\n\n  // 投影面積と体積の情報を追加\n  console.log(`投影面積 - 正面: ${projectedAreas.frontalArea.toFixed(5)}m², 側面: ${projectedAreas.sideArea.toFixed(5)}m²`);\n  console.log(`体積 - ノーズ: ${volumes.noseVolume.toFixed(6)}m³, ボディ: ${volumes.bodyVolume.toFixed(6)}m³, 合計: ${volumes.totalVolume.toFixed(6)}m³`);\n  console.log(`圧力中心位置: ${centerOfPressure.centerOfPressure.toFixed(2)}mm, 空力中心位置: ${aerodynamicCenter.aerodynamicCenter.toFixed(2)}mm`);\n  console.log(`静安定用圧力中心位置: ${stabilityCenterOfPressure.stabilityCenterOfPressure.toFixed(2)}mm`);\n  console.log(`静安定マージン (標準): ${staticMargins.standardStaticMargin.toFixed(2)}, (静安定用): ${staticMargins.stabilityStaticMargin.toFixed(2)}`);\n  return {\n    data,\n    maxHeight,\n    maxSpeed,\n    maxDistance,\n    maxFinDeflection,\n    keyPoints,\n    angleStability: {\n      maxAngleChangePerDt2,\n      isAngleStableOK\n    },\n    projectedAreas,\n    // 投影面積データを追加\n    volumes,\n    // 体積データを追加\n    pressureCenter: centerOfPressure,\n    // 圧力中心データを追加\n    aerodynamicCenter,\n    // 空力中心データを追加\n    stabilityCenterOfPressure,\n    // 静安定用圧力中心を追加\n    staticMargins,\n    // 静安定マージンを追加\n    calculations: {\n      aerodynamicCenter: Math.round(aerodynamicCenter.aerodynamicCenter),\n      pressureCenter: Math.round(centerOfPressure.centerOfPressure),\n      stabilityCenterOfPressure: Math.round(stabilityCenterOfPressure.stabilityCenterOfPressure),\n      standardStaticMargin: parseFloat(staticMargins.standardStaticMargin.toFixed(2)),\n      stabilityStaticMargin: parseFloat(staticMargins.stabilityStaticMargin.toFixed(2)),\n      finDivergenceSpeed: Math.round(calculateFinDivergenceSpeed(rocketParams)),\n      finFlutterSpeed: Math.round(calculateFinFlutterSpeed(rocketParams))\n    }\n  };\n};","map":{"version":3,"names":["MOTOR_THRUST_DATA","PHYSICAL_CONSTANTS","ANGLE_RESPONSE_DT","ANGLE_STEPS_PER_UPDATE","NOSE_SHAPES","FIN_MATERIALS","WIND_PROFILES","mmToM","gToKg","PHYSICAL_ATTITUDE_CONTROL","ENHANCED_ATTITUDE_CONTROL","calculateProjectedArea","rocketParams","console","error","frontalArea","sideArea","finArea","totalFinArea","angledArea","noseShape","noseHeight","bodyHeight","bodyWidth","finHeight","finBaseWidth","finTipWidth","finSweepLength","finThickness","noseHeight_m","bodyHeight_m","bodyWidth_m","bodyRadius_m","finHeight_m","finBaseWidth_m","finTipWidth_m","finSweepLength_m","Math","PI","pow","bodyArea","noseArea","sqrt","calculateVolume","bodyVolume","noseVolume","totalVolume","calculateCenterOfPressure","areas","noseCp","bodyCp","finCP_single","finCp","totalArea","centerOfPressure","foreBodyArea","foreBodyCp","calculateAerodynamicCenter","lengthOfCo","ramda","volumeData","c_bar","y_bar","wingArea","Vstar_fus","aspectRatio","cl_alpha","hn","hnwc_bar","x1","x2","small_xac","aerodynamicCenter","calculateStabilityCenterOfPressure","mc","noseStabilityCp","fin_cn_1","fin_cn_2","fin_cn_3","fin_cn","cnTotal","finStabilityCp","stabilityCenterOfPressure","calculateStaticMargin","centerOfGravity","cpData","stabilityCp","standardStaticMargin","stabilityStaticMargin","calculateFinDivergenceSpeed","finMaterial","finThickness_m","material","G","rho","meanChord","sweepbackAngle","atan","J","liftCoefficient_fin","cos","divSpeed","max","min","calculateFinFlutterSpeed","E","poissonsRatio","empiricalConstant","factorA","factorB","isFinite","warn","flutterSpeed","formatFinDeflection","deflection","toFixed","formatSpeedValue","speed","limit","round","calculateWindSpeedAtHeight","baseWindSpeed","height","profile","alpha","referenceHeight","heightRatio","windSpeedMultiplier","maxMultiplier","actualMultiplier","calculateLiftMoment","velocity","omega","flightAngle","velocitySquared","angleOfAttack","liftCoefficient","momentMagnitude","abs","finalMoment","MIN_MOMENT","sign","calculateDragMoment","dragCoefficient","calculateWindMoment","bodyDiameter","windSpeed","safeWindSpeed","Dwf","Dwb","cosAngle","applyWindDirectionAngleLimit","limitAngle","isMovingUpwind","calculateThrustMoment","thrust","thrustPosition","sin","calculateFinDeflection","finParams","angleChangePerDt2","safeFinThickness","Number","safeAngleChange","safeVelocity","taperRatio","sweepAngle","I","windForce","unitlengthWindForce","deflectionFactor","rawDeflection","isNaN","calculateFlightPath","angle","windProfile","config","prevOmega","currentMaxAngleChange","dt","dt2","mass_kg","weight","thrustData","selectedMotor","launchRailLength","MAX_TIME","bodyRadius","bodyLength","finwidth_m","momentOfInertia","noseCd","cd","thrustEndTime","length","parachuteDelay","parseInt","split","parachuteDeployTime","parachuteEjectionTime","parachuteActiveTime","parachuteDiameter","selectedParachute","slice","projectedAreas","volumes","staticMargins","time","x","y","vx","vy","prev_vx","prev_vy","angularVelocity","angularAcceleration","data","isParachuteEjected","isParachuteActive","parachuteDeploymentProgress","finDeflection","maxAngleChangePerDt2","isAngleStableOK","thrustEndFlag","initialOmegaDegrees","stepCounter","totalTorque","avgThrustForTorque","thrustSamplesCount","g","maxHeight","maxSpeed","maxDistance","maxFinDeflection","keyPoints","thrustEnd","parachuteEjection","parachuteActive","distanceFromStart","onLaunchRail","effectiveWindSpeed","ax","ay","torque","Fx","Fy","angleAdjustment","adjustedOmega","Cd","Area","Dp","Cdw","S","Dw","initialOmega","Dt","thrustIndex","floor","atan2","ML","MD","MW","MT","rawTorque","MIN_TORQUE_THRESHOLD","log","avgTorque","safeAvgTorque","MIN_TORQUE","effectiveTorque","oldAngularVelocity","MIN_ANGLE_CHANGE_PER_DT2","angleChangePerDt2Degrees","physicsBasedAngleChange","MIN_ANGLE_CHANGE","targetOmega","adjustRate","newOmega","maxChange","windAngle","perpendicularToWind1","perpendicularToWind2","windFactor","finalAdjustRate","MAX_SPEED","currentSpeed","factor","MAX_ANGULAR_VELOCITY","railDistance","push","physicsX","physicsY","speedMagnitude","accelerationMagnitude","horizontalDistance","angleDeviationDegrees","angleStability","pressureCenter","calculations","parseFloat","finDivergenceSpeed","finFlutterSpeed"],"sources":["/Users/shinoharatsubasa/Documents/RocketSim_New_2d_integ/src/components/rocket/RocketPhysics.jsx"],"sourcesContent":["// 物理計算関連の関数\nimport { \n  MOTOR_THRUST_DATA, PHYSICAL_CONSTANTS, \n  ANGLE_RESPONSE_DT, ANGLE_STEPS_PER_UPDATE,\n  NOSE_SHAPES, FIN_MATERIALS, WIND_PROFILES, mmToM, gToKg \n} from './RocketConstants';\n\n// 物理制御と拡張制御を分離する定数を追加\nexport const PHYSICAL_ATTITUDE_CONTROL = true;  // 物理ベースの姿勢制御 (常に有効にすべき)\nexport const ENHANCED_ATTITUDE_CONTROL = false;  // 拡張姿勢制御 (風見効果など)\n\n// ロケットの投影面積を計算する関数\nexport const calculateProjectedArea = (rocketParams) => {\n  \n  // パラメータの存在と型チェック\n  if (!rocketParams || typeof rocketParams !== 'object') {\n    console.error('calculateProjectedArea: 無効なrocketParamsオブジェクト', rocketParams);\n    return { \n      frontalArea: 0, \n      sideArea: 0, \n      finArea: 0, \n      totalFinArea: 0, \n      angledArea: 0 \n    };\n  }\n\n    // 必須パラメータの存在チェック\n    const { \n      noseShape, noseHeight, bodyHeight, bodyWidth, \n      finHeight, finBaseWidth, finTipWidth, finSweepLength, finThickness \n    } = rocketParams;\n  \n    // 必須パラメータが存在しない場合はエラーログを出力し、安全な値を返す\n    if (\n      typeof noseHeight !== 'number' || \n      typeof bodyHeight !== 'number' || \n      typeof bodyWidth !== 'number' || \n      typeof finHeight !== 'number' || \n      typeof finBaseWidth !== 'number' || \n      typeof finTipWidth !== 'number' || \n      typeof finThickness !== 'number' || \n      typeof finSweepLength !== 'number'\n    ) {\n      console.error('calculateProjectedArea: 必須の数値パラメータが不足しています', {\n        noseHeight, bodyHeight, bodyWidth, finHeight, finBaseWidth, finTipWidth, finThickness, finSweepLength\n      });\n      return { \n        frontalArea: 0, \n        sideArea: 0, \n        finArea: 0, \n        totalFinArea: 0, \n        angledArea: 0 \n      };\n    }\n\n  // 単位をmm->mに変換\n  const noseHeight_m = mmToM(noseHeight);\n  const bodyHeight_m = mmToM(bodyHeight);\n  const bodyWidth_m = mmToM(bodyWidth);\n  const bodyRadius_m = bodyWidth_m / 2;\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finSweepLength_m = mmToM(finSweepLength);\n  \n  // 正面からの投影面積 (m^2)\n  const frontalArea = Math.PI * Math.pow(bodyRadius_m, 2) + (finHeight * finThickness) * 4 * 0.0000001;\n  \n  // 側面投影面積の計算 (m^2)\n  // ボディ部分\n  const bodyArea = bodyWidth_m * bodyHeight_m;\n  \n  // ノーズ部分 - 形状に応じて計算\n  let noseArea;\n  if (noseShape === 'cone') {\n    noseArea = 0.5 * bodyWidth_m * noseHeight_m; // 三角形の面積\n  } else if (noseShape === 'parabola') {\n    noseArea = (2/3) * bodyWidth_m * noseHeight_m; // 放物線の近似\n  } else { // ogive\n    noseArea = (2/3) * bodyWidth_m * noseHeight_m; // オジブの近似\n  }\n  \n  // フィン1枚あたりの投影面積\n  const finArea = finHeight_m * (finBaseWidth_m + finTipWidth_m) / 2; // 台形の面積\n  \n  // フィン4枚の合計投影面積\n  const totalFinArea = finArea * 2;\n  \n  // 側面からの合計投影面積\n  const sideArea = bodyArea + noseArea + totalFinArea;\n  \n  // 斜め45度からの投影面積（近似）（修正が必要）\n  const angledArea = Math.sqrt(Math.pow(frontalArea, 2) + Math.pow(sideArea, 2));\n  \n  return {\n    frontalArea,  // 正面からの投影面積 (m^2)\n    sideArea,     // 側面からの投影面積 (m^2)\n    finArea,      // フィン1枚の投影面積 (m^2)\n    totalFinArea, // フィン4枚の合計投影面積 (m^2)\n    angledArea    // 斜め45度からの投影面積（近似） (m^2)\n  };\n};\n\n// ロケットの体積を計算する関数\nexport const calculateVolume = (rocketParams) => {\n  const { noseShape, noseHeight, bodyHeight, bodyWidth } = rocketParams;\n  \n  // 単位をmm->mに変換\n  const noseHeight_m = mmToM(noseHeight);\n  const bodyHeight_m = mmToM(bodyHeight);\n  const bodyRadius_m = mmToM(bodyWidth) / 2;\n  \n  // ボディ体積（円柱） (m^3)\n  const bodyVolume = Math.PI * Math.pow(bodyRadius_m, 2) * bodyHeight_m;\n  \n  // ノーズ体積 - 形状に応じて計算 (m^3)\n  let noseVolume;\n  if (noseShape === 'cone') {\n    noseVolume = (1/3) * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // 円錐の体積\n  } else if (noseShape === 'parabola') {\n    noseVolume = (1/2) * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // 放物線回転体の体積\n  } else { // ogive\n    noseVolume = (2/3) * Math.PI * Math.pow(bodyRadius_m, 2) * noseHeight_m; // オジブの近似体積\n  }\n  \n  // 合計体積 (m^3)\n  const totalVolume = bodyVolume + noseVolume;\n  \n  // フィンの体積は非常に小さいため、ここでは無視する\n  \n  return {\n    bodyVolume,  // ボディ部分の体積 (m^3)\n    noseVolume,  // ノーズ部分の体積 (m^3)\n    totalVolume  // 合計体積 (m^3)\n  };\n};\n\n// 圧力中心位置を計算する関数（モーメント計算に使用）\nexport const calculateCenterOfPressure = (rocketParams) => {\n  const { noseShape, noseHeight, bodyHeight, bodyWidth, finHeight, finBaseWidth, finTipWidth, finSweepLength } = rocketParams;\n  \n  // 面積と体積を計算\n  const areas = calculateProjectedArea(rocketParams);\n  \n  // ノーズ先端からの各コンポーネントの圧力中心位置 (mm)\n  // ノーズの圧力中心位置 - 形状に応じて計算\n  let noseCp;\n  if (noseShape === 'cone') {\n    noseCp = noseHeight * (2/3); // 円錐の圧力中心はノーズ長の2/3\n  } else if (noseShape === 'parabola') {\n    noseCp = noseHeight * (3/5); // 放物線の圧力中心（近似値）\n  } else { // ogive\n    noseCp = noseHeight * (3/5); // オジブの圧力中心（近似値）\n  }\n  \n  // ボディの圧力中心位置（ノーズ先端から）\n  const bodyCp = noseHeight + bodyHeight / 2; // mm\n  \n  //　フィンの圧力中心位置（フィン付け根先端から）\n  const finCP_single = (Math.pow((finSweepLength + finTipWidth), 2) - Math.pow(finSweepLength, 2) + Math.pow(finBaseWidth, 2) + (finSweepLength + finTipWidth) * finBaseWidth) / (3 * ((finSweepLength + finTipWidth) + finBaseWidth - finSweepLength)); // mm\n\n  // フィンの圧力中心位置（ノーズ先端から）\n  const finCp = noseHeight + bodyHeight - finBaseWidth + finCP_single; // mm\n  \n  // 面積による重み付け計算\n  // 単位を揃えるためにm²からmm²に変換\n  const noseArea = areas.noseArea * 1000000; // m^2 → mm^2\n  const bodyArea = areas.sideArea * 1000000 - noseArea; // m^2 → mm^2\n  const totalFinArea = areas.totalFinArea * 1000000; // m^2 → mm^2\n  \n  // 圧力中心の計算（重み付け平均）\n  const totalArea = noseArea + bodyArea + totalFinArea;\n  const centerOfPressure = (noseCp * noseArea + bodyCp * bodyArea + finCp * totalFinArea) / totalArea; // mm\n  \n  // フィンを除いた前部の圧力中心（空力計算用）\n  const foreBodyArea = noseArea + bodyArea;\n  const foreBodyCp = (noseCp * noseArea + bodyCp * bodyArea) / foreBodyArea;\n  \n  return {\n    noseCp,           // ノーズの圧力中心位置 (mm)\n    bodyCp,           // ボディの圧力中心位置 (mm)\n    finCp,            // フィンの圧力中心位置 (mm)\n    centerOfPressure, // 全体の圧力中心位置 (mm)\n    foreBodyCp        // フィンを除いた前部の圧力中心位置 (mm)\n  };\n};\n\n// 空力中心位置を計算する関数\nexport const calculateAerodynamicCenter = (rocketParams) => {\n  // この行で必要なすべてのプロパティを取り出します\n  const { noseHeight, bodyHeight, bodyWidth, finHeight, finBaseWidth, finTipWidth, finSweepLength } = rocketParams;\n  \n  // 投影面積を計算\n  const areas = calculateProjectedArea(rocketParams);\n\n  // lengthOfCo\n  const lengthOfCo = ((finBaseWidth - finTipWidth) / finHeight) * ((bodyWidth / 2) + finHeight) + finTipWidth;\n  \n  // テーパー比（ramda）\n  const ramda = finTipWidth / lengthOfCo;\n\n  // 胴体容積 (m^3)\n  const volumeData = calculateVolume(rocketParams);\n\n  // c_bar\n  const c_bar = (2 * lengthOfCo / 3) * (1 + ramda + Math.pow(ramda, 2)) / (1 + ramda);\n\n  // y_bar\n  const y_bar = (finHeight + (bodyWidth / 2)) * (1 + (2 * ramda)) / (3 * (1 + ramda));\n\n  // 面積による重み付け計算（m^2をmm^2に変換）\n  const noseArea = areas.noseArea * 1000000; // m^2 → mm^2\n  const bodyArea = areas.sideArea * 1000000 - noseArea; // m^2 → mm^2\n  const totalFinArea = areas.totalFinArea * 1000000; // m^2 → mm^2\n\n  // WingArea\n  const wingArea = (finTipWidth + lengthOfCo) * ((bodyWidth / 2) + finHeight);\n  \n  // V*fus\n  const Vstar_fus = volumeData.totalVolume * 1000000000 / (c_bar * wingArea); // 単位を合わせる\n\n  // AspectRatio\n  const aspectRatio = ((2 * finHeight) + bodyWidth) * ((2 * finHeight) + bodyWidth) / wingArea;\n\n  // CLα\n  const cl_alpha = ((3.14 * aspectRatio) * 0.5) * Math.pow((1 - Math.pow((bodyWidth / 2) / (((finHeight + (bodyWidth / 2)) / 2)), 2)) , 2);\n\n  // hn\n  const hn = 0.25 + (1 / cl_alpha) * (-1) * (2 * Vstar_fus);\n\n  // hnwc_bar\n  const hnwc_bar = hn * c_bar;\n\n  // x1\n  const x1 = (bodyWidth / 2) * finSweepLength / finHeight;\n\n  // x2\n  const x2 = y_bar * (x1 + finSweepLength + finTipWidth - lengthOfCo) / (((bodyWidth / 2) + finHeight));\n\n  // small_xac\n  const small_xac = c_bar - x2 - hnwc_bar;\n\n  // 空力中心計算\n  const aerodynamicCenter = noseHeight + bodyHeight - small_xac;\n  \n  return {\n    aerodynamicCenter  // 空力中心位置 (mm)\n  };\n};\n\n// 静安定マージン計算用の圧力中心位置を計算する関数\nexport const calculateStabilityCenterOfPressure = (rocketParams) => {\n  const { noseShape, noseHeight, bodyHeight, bodyWidth, finHeight, finBaseWidth, finTipWidth, finSweepLength } = rocketParams;\n\n  // mc\n  const mc = Math.pow((Math.pow((finSweepLength + (finTipWidth / 2) - (finBaseWidth / 2)), 2)) + (Math.pow(finHeight, 2)), 0.5);\n  \n  // ノーズ先端からの位置を計算 (mm)\n  // この静安定マージン用の圧力中心は通常の圧力中心とは異なる計算方法を使用\n  \n  // ノーズの圧力中心\n  let noseStabilityCp;\n  if (noseShape === 'cone') {\n    noseStabilityCp = noseHeight * 0.5; // 円錐の静安定用圧力中心\n  } else if (noseShape === 'parabola') {\n    noseStabilityCp = noseHeight * 0.45; // 放物線の静安定用圧力中心\n  } else { // ogive\n    noseStabilityCp = noseHeight * 0.4; // オジブの静安定用圧力中心\n  }\n  \n  // フィンのcn\n  const fin_cn_1 = 1 + (finHeight / (finHeight + (bodyWidth / 2)));\n  const fin_cn_2 = 4 * 4 * Math.pow((finHeight / (bodyWidth / 2)), 2);\n  const fin_cn_3 = 1 + Math.pow((1 + (Math.pow(((2 * mc) / (finTipWidth + finBaseWidth)), 2))), 0.5);\n  const fin_cn = fin_cn_1 * fin_cn_2 / fin_cn_3;\n\n  // CnTotal\n  const cnTotal = 2 + fin_cn;\n\n  // フィンの圧力中心\n  const finStabilityCp = (noseHeight + bodyHeight - finBaseWidth) + ((finSweepLength / 3) * ((finBaseWidth + 2 * finTipWidth) / (finBaseWidth + finTipWidth))) + ((finBaseWidth + finTipWidth) - ((finBaseWidth * finTipWidth) / (finBaseWidth + finTipWidth))) / 6;\n  \n  // 静安定用の圧力中心位置（重み付け平均）\n  const stabilityCenterOfPressure = (2 * noseStabilityCp + fin_cn * finStabilityCp) / cnTotal;\n  \n  return {\n    stabilityCenterOfPressure,  // 静安定計算用の圧力中心位置 (mm)\n  };\n};\n\n// 静安定マージンを計算する関数\nexport const calculateStaticMargin = (rocketParams) => {\n  const { centerOfGravity, bodyWidth } = rocketParams;\n  \n  // 通常の圧力中心を計算\n  const cpData = calculateCenterOfPressure(rocketParams);\n  \n  // 静安定計算用の特別な圧力中心を計算\n  const stabilityCp = calculateStabilityCenterOfPressure(rocketParams);\n  \n  // 静安定マージン = (圧力中心位置 - 重心位置) / ボディ直径\n  // 通常の圧力中心を使用した場合\n  const standardStaticMargin = (cpData.centerOfPressure - centerOfGravity) / bodyWidth;\n  \n  // 静安定用圧力中心を使用した場合\n  const stabilityStaticMargin = (stabilityCp.stabilityCenterOfPressure - centerOfGravity) / bodyWidth;\n  \n  return {\n    standardStaticMargin,   // 通常の静安定マージン\n    stabilityStaticMargin   // 静安定計算用の静安定マージン\n  };\n};\n\n// フィンダイバージェンス速度を計算する関数\nexport const calculateFinDivergenceSpeed = (rocketParams) => {\n  const { finHeight, finBaseWidth, finTipWidth, finSweepLength, finThickness, finMaterial } = rocketParams;\n  \n  // 単位をmmからmに変換\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finSweepLength_m = mmToM(finSweepLength);\n  const finThickness_m = mmToM(finThickness);\n  \n  // フィン材料の特性を取得\n  const material = FIN_MATERIALS[finMaterial];\n  const G = material.G; // 横弾性係数 (Pa)\n  \n  // 空気密度 (kg/m³)\n  const rho = 1.225;\n\n  // 平均コード長の計算 (m)\n  const meanChord = (finBaseWidth_m + finTipWidth_m) / 2;\n  \n  // 後退角(rad)\n  const sweepbackAngle = Math.atan((finSweepLength_m + 0.5 * finTipWidth_m - 0.5 * finBaseWidth_m) * 3.14 / meanChord);\n\n  // 捻り定数J\n  const J = 0.3333 * finTipWidth_m * Math.pow(finThickness_m, 3);\n\n  // 揚力傾斜a0\n  const liftCoefficient_fin = (9 / 3.14) * Math.cos(sweepbackAngle);\n  \n  const divSpeed = (3.14 / (2 * finHeight_m)) * Math.pow( 2 * G * J / (rho * Math.pow(meanChord, 2) * 0.25 * liftCoefficient_fin), 0.5);\n  \n  // 現実的な範囲内に制限（極端に大きな/小さな値を防止）\n  return Math.max(20, Math.min(300, divSpeed));\n};\n\n// フィンフラッター速度を計算する関数\nexport const calculateFinFlutterSpeed = (rocketParams) => {\n  const { finHeight, finBaseWidth, finTipWidth, finThickness, finMaterial } = rocketParams;\n  \n  // 単位をmmからmに変換\n  const finHeight_m = mmToM(finHeight);\n  const finBaseWidth_m = mmToM(finBaseWidth);\n  const finTipWidth_m = mmToM(finTipWidth);\n  const finThickness_m = mmToM(finThickness);\n  \n  // フィン材料の特性を取得\n  const material = FIN_MATERIALS[finMaterial];\n  const G = material.G; // 横弾性係数 (Pa)\n  const E = material.E; // 縦弾性係数 (Pa)\n  \n  // ポアソン比（一般的な値）\n  const poissonsRatio = 0.3;\n  \n  // 空気密度 (kg/m³)\n  const rho = 1.225;\n  \n  // 平均コード長の計算 (m)\n  const meanChord = (finBaseWidth_m + finTipWidth_m) / 2;\n  \n  // 経験的定数\n  const empiricalConstant = 3.5;\n  \n  // フィンフラッター速度の計算 (m/s)\n  // V_flutter = (a * t / c^1.5) * sqrt(G * E / (12 * ρ * (1 - ν^2)))\n  const factorA = empiricalConstant * finThickness_m / Math.pow(meanChord, 1.5);\n  const factorB = Math.sqrt(G * E / (12 * rho * (1 - Math.pow(poissonsRatio, 2))));\n  \n  // 計算結果が無効な場合のフォールバック\n  if (!isFinite(factorA) || !isFinite(factorB)) {\n    console.warn('フィンフラッター速度の計算に無効な値が発生しました。代替値を使用します。');\n    return 40 + mmToM(rocketParams.bodyHeight + rocketParams.noseHeight) * 120;\n  }\n  \n  const flutterSpeed = factorA * factorB;\n  \n  // 現実的な範囲内に制限（極端に大きな/小さな値を防止）\n  return Math.max(30, Math.min(400, flutterSpeed));\n};\n\n// フィンたわみ量のフォーマット関数（UI表示時に使用）\nexport const formatFinDeflection = (deflection) => {\n  // 15mmの場合（閾値または計算エラー）は「15mm以上」と表示\n  if (deflection === 15) {\n    return \"15mm以上\";\n  }\n  \n  // 通常のたわみ量は小数点2桁までの数値を表示\n  return `${deflection.toFixed(2)}mm`;\n};\n\n// フィンダイバージェンス速度とフラッター速度の表示用フォーマット関数\nexport const formatSpeedValue = (speed, limit = 300) => {\n  // 速度値が上限を超えている場合\n  if (speed >= limit) {\n    return `${limit}+ m/s`;  // 「300+ m/s」のように表示\n  }\n  \n  // 通常範囲内の速度は整数で表示\n  return `${Math.round(speed)} m/s`;\n};\n\n// 高度に応じた風速を計算する関数 - 基準高度を1.5mに修正\nexport const calculateWindSpeedAtHeight = (baseWindSpeed, height, profile) => {\n  // 高度が0の場合はそのまま基準風速を返す\n  if (height <= 0) return baseWindSpeed;\n  \n  // プロファイルに応じたべき指数を取得\n  const alpha = WIND_PROFILES[profile].alpha;\n  \n  // べき指数が0の場合は高度に関わらず一定風速\n  if (alpha === 0) return baseWindSpeed;\n  \n  // 基準高度（1.5メートル - 地上計測を想定）\n  const referenceHeight = 1.5; \n  \n  // べき乗則による風速計算\n  // V(h) = V_ref * (h/h_ref)^α\n  const heightRatio = height / referenceHeight;\n  const windSpeedMultiplier = Math.pow(heightRatio, alpha);\n  \n  // 風速の上限を設定（非現実的な値にならないよう制限）\n  const maxMultiplier = 3.0; // 基準風速の3倍まで\n  const actualMultiplier = Math.min(windSpeedMultiplier, maxMultiplier);\n  \n  return baseWindSpeed * actualMultiplier;\n};\n\n// モーメント計算用のヘルパー関数 - 修正版\nconst calculateLiftMoment = (velocity, omega, flightAngle, rocketParams, sideArea, aerodynamicCenter, centerOfGravity) => {\n  const velocitySquared = Math.min(velocity * velocity, 10000);\n  \n  // 迎角（姿勢角と飛行角の差）を計算\n  const angleOfAttack = omega - flightAngle;\n  \n  // 迎角に比例した揚力係数（小さな角度ではsin(θ)≈θ）\n  // より大きな係数を使用してモーメントを増加\n  const liftCoefficient = 0.6 * angleOfAttack;  // 係数は0.6\n  \n  // 揚力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(liftCoefficient * 0.5 * 1.225 * velocitySquared * sideArea * (aerodynamicCenter - centerOfGravity) * 0.001);\n  \n  // 符号の決定\n  let finalMoment;\n  if ((aerodynamicCenter >= centerOfGravity && angleOfAttack < 0) || \n      (aerodynamicCenter < centerOfGravity && angleOfAttack >= 0)) {\n    finalMoment = -momentMagnitude; // マイナス\n  } else {\n    finalMoment = momentMagnitude;  // プラス\n  }\n\n  // 最小モーメント保証 (非常に小さな値になるのを防ぐ)\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  \n  // 角度が大きすぎる場合はモーメントを増加\n  if (Math.abs(angleOfAttack) > 0.5) {  // 約28.6度以上\n    return finalMoment * 1.2;  // モーメントを20%増加\n  }\n  \n  return finalMoment;\n};\n\nconst calculateDragMoment = (velocity, omega, flightAngle, rocketParams, sideArea, aerodynamicCenter, centerOfGravity) => {\n  const velocitySquared = Math.min(velocity * velocity, 10000);\n  \n  // 迎角を計算\n  const angleOfAttack = omega - flightAngle;\n  \n  // 迎角の二乗に比例した抗力増加\n  const dragCoefficient = 0.01 * Math.pow(angleOfAttack, 2) - 0.02 * angleOfAttack + 0.63;\n  \n  // 抗力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(dragCoefficient * 0.5 * 1.225 * velocitySquared * sideArea * (aerodynamicCenter - centerOfGravity) * 0.001);\n  \n  // 符号の決定\n  let finalMoment;\n  if ((aerodynamicCenter >= centerOfGravity && angleOfAttack < 0) || \n      (aerodynamicCenter < centerOfGravity && angleOfAttack >= 0)) {\n    finalMoment = -momentMagnitude; // マイナス\n  } else {\n    finalMoment = momentMagnitude;  // プラス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  \n  return finalMoment;\n};\n\nconst calculateWindMoment = (noseHeight, bodyDiameter, bodyHeight, windSpeed, omega, totalFinArea, centerOfPressure, centerOfGravity) => {\n  // 風速に上限を設定\n  const safeWindSpeed = Math.max(-25, Math.min(25, windSpeed));\n\n  // 風速によりフィンが受ける力\n  const Dwf = 9.81 * 0.05 * Math.pow(safeWindSpeed, 2) * totalFinArea;\n\n  // 風速によりボディが受ける力\n  const Dwb = 0.23 * 0.5 * 1.225 * Math.pow(safeWindSpeed, 2) * bodyDiameter * (bodyHeight + noseHeight) / 1000000;\n\n  // 安全なコサイン計算\n  const cosAngle = Math.cos(omega);\n\n  // 風モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs((Dwf + Dwb) * cosAngle * (centerOfPressure - centerOfGravity) * 0.001);\n  \n  // 符号の決定\n  let finalMoment;\n  if ((centerOfPressure >= centerOfGravity && windSpeed < 0) || \n      (centerOfPressure < centerOfGravity && windSpeed >= 0)) {\n    finalMoment = momentMagnitude;  // プラス\n  } else {\n    finalMoment = -momentMagnitude; // マイナス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  \n  return finalMoment;\n};\n\n// 風見効果による角度制限関数\nconst applyWindDirectionAngleLimit = (omega, windSpeed) => {\n  // 風速が非常に小さい場合は制限なし\n  if (Math.abs(windSpeed) < 0.5) return omega;\n  \n  // 風向きに応じた制限角度（ラジアン）\n  // 風が右から左（負の風速）なら -90度に制限（風上である右向き）\n  // 風が左から右（正の風速）なら +90度に制限（風上である左向き）\n  const limitAngle = Math.sign(windSpeed) * Math.PI / 2;\n  \n  // 風上に向かっているかどうか\n  // 風が右から左（負の風速）で機体が右向き（負の角度）に傾いている場合\n  // または、風が左から右（正の風速）で機体が左向き（正の角度）に傾いている場合\n  const isMovingUpwind = (windSpeed < 0 && omega < 0) || (windSpeed > 0 && omega > 0);\n  \n  // 角度制限を適用（風上へ向かう場合のみ）\n  if (isMovingUpwind) {\n    // 角度が制限値を超えているかチェック\n    if ((windSpeed < 0 && omega < limitAngle) || (windSpeed > 0 && omega > limitAngle)) {\n      // 制限角度に制限\n      return limitAngle;\n    }\n  }\n  \n  // それ以外の場合は元の角度をそのまま返す\n  return omega;\n};\n\n// 推力モーメント計算関数\nconst calculateThrustMoment = (thrust, centerOfGravity, omega, flightAngle, rocketParams) => {\n  const { noseHeight, bodyHeight } = rocketParams;\n  \n  // 迎角を計算\n  const angleOfAttack = omega - flightAngle;\n  \n  // 推力発生位置（ロケットの最後尾）\n  const thrustPosition = noseHeight + bodyHeight;\n  \n  // 推力モーメントの計算 - 絶対値のみを計算\n  const momentMagnitude = Math.abs(thrust * Math.sin(angleOfAttack) * Math.cos(angleOfAttack) * (thrustPosition - centerOfGravity) * 0.001);\n  \n  // 符号の決定\n  let finalMoment;\n  if ((thrustPosition >= centerOfGravity && angleOfAttack < 0) || \n      (thrustPosition < centerOfGravity && angleOfAttack >= 0)) {\n    finalMoment = momentMagnitude;  // プラス\n  } else {\n    finalMoment = -momentMagnitude; // マイナス\n  }\n\n  // 最小モーメント保証\n  const MIN_MOMENT = 0.00001;\n  if (Math.abs(finalMoment) > 0 && Math.abs(finalMoment) < MIN_MOMENT) {\n    return Math.sign(finalMoment) * MIN_MOMENT;\n  }\n  \n  return finalMoment;\n};\n\n// フィンのたわみ量計算\nconst calculateFinDeflection = (velocity, material, finParams, angleChangePerDt2) => {\n  const { finHeight, finBaseWidth, finTipWidth, finThickness, finSweepLength } = finParams;\n  const { E } = material;\n\n  // 速度0の場合は早期リターン\n  if (Math.abs(velocity) < 0.001) return 0;\n\n  // finThicknessが小数の場合も適切に扱えるように\n  const safeFinThickness = Number(finThickness) || 2.0; // デフォルト値として2.0mm\n\n  // 安全な角度変化量を確保\n  const safeAngleChange = Math.max(-0.5, Math.min(0.5, angleChangePerDt2));\n\n  // 安全な速度（極端に大きな値を制限）\n  const safeVelocity = Math.min(velocity, 300);\n\n  try {\n    // フィンの面積（m^2）\n    const finArea = ((finBaseWidth + finTipWidth) * 0.001) * (finHeight * 0.001) / 2;\n    \n    // テーパー比（無次元）- 分母0防止\n    let taperRatio = 0;\n    if (finHeight > 0) {\n      taperRatio = ((finBaseWidth * 0.001) - (finTipWidth * 0.001)) / (finHeight * 0.001);\n      // 極端な値の制限\n      taperRatio = Math.max(-0.9, Math.min(0.9, taperRatio));\n    }\n    \n    // 後退角（ラジアン）\n    const sweepAngle = Math.atan((finSweepLength * 0.001 + 0.5 * finTipWidth * 0.001 - 0.5 * finBaseWidth * 0.001) * Math.PI / (finHeight * 0.001));\n    \n    // 断面二次モーメント（近似）- 分母0防止\n    let I = 0;\n    if (finTipWidth > 0 && safeFinThickness > 0) {\n      I = (finTipWidth * 0.001 * Math.pow((safeFinThickness * 0.001), 3)) / 12;\n    }\n    \n    // I値が極端に小さい（または0）の場合は安全値を設定\n    if (I < 1e-12) {\n      I = 1e-12; // 極小値を設定して分母0を防止\n    }\n    \n    // 風圧による力（F）- 速度の二乗に比例\n    const windForce = (9.81 * 0.05 * safeVelocity * safeVelocity) * Math.sin(safeAngleChange) * finArea;\n\n    // 単位長さあたりの風圧による力\n    const unitlengthWindForce = windForce / Math.max(0.001, (finHeight * 0.001));\n    \n    // たわみ量計算（mm）\n    const deflectionFactor = (1 / (1 - taperRatio));\n    const rawDeflection = (unitlengthWindForce * Math.pow((finHeight * 0.001), 4) * Math.cos(sweepAngle) / (8 * E * I)) * deflectionFactor;\n    \n    // NaNチェック\n    if (isNaN(rawDeflection)) {\n      console.warn('フィンたわみ量計算でNaNが発生しました');\n      return 15; // NaNの場合は閾値を返す（表示時に変換）\n    }\n    \n    // たわみ量の絶対値が15mmを超える場合は15に制限\n    if (Math.abs(rawDeflection) > 15) {\n      // 15mmを超えるたわみ → 15を返す（表示時に「15mm以上」に変換）\n      return 15;\n    }\n    \n    // 通常範囲内のたわみ量\n    return rawDeflection;\n    \n  } catch (error) {\n    console.error(\"Fin deflection calculation error:\", error);\n    return 15; // エラー時は閾値を返す（表示時に「15mm以上」に変換）\n  }\n};\n\n// 物理計算 (calculateFlightPath関数の完全実装)\nexport const calculateFlightPath = (rocketParams, angle, windSpeed, windProfile, config) => {\n  // 角度変化を記録するための変数\n  let prevOmega = angle * Math.PI / 180; // 前フレームの角度（初期値は発射角度）\n  let currentMaxAngleChange = 0; // 直接更新用の最大角度変化量\n  const dt = 0.02;\n  const dt2 = ANGLE_RESPONSE_DT; // 角度応答時間\n  const mass_kg = gToKg(rocketParams.weight);\n  const thrustData = MOTOR_THRUST_DATA[rocketParams.selectedMotor];\n  const launchRailLength = PHYSICAL_CONSTANTS.launchRailLength; // 発射台の長さ (m)\n  const MAX_TIME = 20; // 最大シミュレーション時間 (s)\n\n  // ロケットの物理パラメータ\n  const bodyDiameter = mmToM(rocketParams.bodyWidth); // ロケット直径 (m)\n  const bodyRadius = bodyDiameter / 2; // ロケット半径 (m)\n  const bodyLength = mmToM(rocketParams.bodyHeight + rocketParams.noseHeight); // ロケット全長 (m)\n  const finwidth_m = mmToM(rocketParams.finHeight); // フィン幅\n  const finThickness_m = mmToM(rocketParams.finThickness);\n  const PI = Math.PI;\n  \n  // 慣性モーメントの計算 (I = 0.25*m*r^2 + 0.833*m*l^2)\n  const momentOfInertia = 0.25 * mass_kg * bodyRadius * bodyRadius + 0.833 * mass_kg * bodyLength * bodyLength;\n\n  // ノーズ形状に基づく抗力係数\n  const noseCd = NOSE_SHAPES[rocketParams.noseShape].cd;\n  \n  // フィン材料特性\n  const finMaterial = FIN_MATERIALS[rocketParams.finMaterial];\n\n  // パラシュート関連の定数\n  const thrustEndTime = thrustData.length * dt;\n  const parachuteDelay = parseInt(rocketParams.selectedMotor.split('-')[1]);\n  const parachuteDeployTime = 1.0;\n  const parachuteEjectionTime = thrustEndTime + parachuteDelay;\n  const parachuteActiveTime = parachuteEjectionTime + parachuteDeployTime;\n  const parachuteDiameter = mmToM(parseInt(rocketParams.selectedParachute.slice(1))); // φ180 -> 180mm -> 0.18m\n\n  // 新しい計算 - 投影面積と圧力中心の計算\n  const projectedAreas = calculateProjectedArea(rocketParams);\n  const centerOfPressure = calculateCenterOfPressure(rocketParams);\n  const aerodynamicCenter = calculateAerodynamicCenter(rocketParams);\n  const stabilityCenterOfPressure = calculateStabilityCenterOfPressure(rocketParams);\n  \n  // 体積計算\n  const volumes = calculateVolume(rocketParams);\n  \n  // 静安定マージン計算\n  const staticMargins = calculateStaticMargin(rocketParams);\n\n  // 状態変数の初期化\n  let time = 0;\n  let x = 0; // メートル単位\n  let y = 0; // メートル単位\n  let vx = 0;\n  let vy = 0;\n  let prev_vx = 0;\n  let prev_vy = 0;\n  let omega = angle * Math.PI / 180; // 初期角度（ラジアン）\n  let angularVelocity = 0; // 角速度\n  let angularAcceleration = 0; // 角加速度\n  let data = [];\n  let isParachuteEjected = false;\n  let isParachuteActive = false;\n  let parachuteDeploymentProgress = 0;\n  let finDeflection = 0; // フィンのたわみ量（mm）\n  \n  // 姿勢安定性チェック用の変数を追加\n  let maxAngleChangePerDt2 = 0; // dt2時間あたりの最大角度変化量\n  let isAngleStableOK = true; // 姿勢安定性の判定\n  let thrustEndFlag = false; // 推力終了フラグ\n  const initialOmegaDegrees = angle; // 初期角度（度）\n  \n  // 角度計算用変数\n  let stepCounter = 0;\n  let totalTorque = 0;\n  let avgThrustForTorque = 0;\n  let thrustSamplesCount = 0;\n  let angleChangePerDt2 = 0; // dt2時間あたりの角度変化量 (ν)\n  \n  // 重力加速度\n  const g = 9.81; // m/s²\n\n  // 記録用変数\n  let maxHeight = 0;\n  let maxSpeed = 0;\n  let maxDistance = 0; // 最大水平距離を記録\n  let maxFinDeflection = 0; // 最大フィンたわみ量\n  \n  // キーポイント記録\n  let keyPoints = {\n    thrustEnd: { time: 0, height: 0, speed: 0 },\n    maxHeight: { time: 0, height: 0, speed: 0 },\n    parachuteEjection: { time: 0, height: 0, speed: 0 },\n    parachuteActive: { time: 0, height: 0, speed: 0 }\n  };\n\n  // シミュレーションループ\n  while ((y >= 0 || time < 0.1) && time < MAX_TIME) {\n    // 前回の速度を保存\n    prev_vx = vx;\n    prev_vy = vy;\n\n    // パラシュート状態の更新\n    if (!isParachuteEjected && time >= parachuteEjectionTime) {\n      isParachuteEjected = true;\n      keyPoints.parachuteEjection = { time, height: y, speed: vy };\n    }\n    \n    if (isParachuteEjected && !isParachuteActive) {\n      parachuteDeploymentProgress = Math.min(1, \n        (time - parachuteEjectionTime) / parachuteDeployTime);\n    }\n    \n    if (!isParachuteActive && time >= parachuteActiveTime) {\n      isParachuteActive = true;\n      parachuteDeploymentProgress = 1.0;\n      \n      // パラシュート展開時は速度を90%減少\n      vx = vx * 0.1;\n      vy = vy * 0.1;\n      \n      keyPoints.parachuteActive = { time, height: y, speed: vy };\n    }\n\n    const distanceFromStart = Math.sqrt(x * x + y * y);\n    const onLaunchRail = distanceFromStart < launchRailLength;\n\n    // 速度の大きさ\n    const velocity = Math.sqrt(prev_vx * prev_vx + prev_vy * prev_vy);\n    \n    // 現在の高度に基づく有効風速を計算\n    const effectiveWindSpeed = calculateWindSpeedAtHeight(windSpeed, y, windProfile);\n    \n    // 力と加速度の初期化\n    let ax = 0;\n    let ay = -g;\n    let torque = 0; // トルク\n    let Fx = 0;\n    let Fy = 0;\n    let thrust = 0;\n\n    // 特定の角度への対応\n    const angleAdjustment = Math.abs(angle) === 4 || Math.abs(angle) === 18 ? 0.01 : 0;\n    const adjustedOmega = omega + angleAdjustment * (angle < 0 ? -1 : 1);\n\n    // フィンのたわみ量計算\n    if (velocity > 5.0) {\n      const finParams = {\n        finHeight: rocketParams.finHeight,\n        finBaseWidth: rocketParams.finBaseWidth,\n        finTipWidth: rocketParams.finTipWidth,\n        finThickness: rocketParams.finThickness,\n        finSweepLength: rocketParams.finSweepLength\n      };\n      \n      finDeflection = calculateFinDeflection(velocity, finMaterial, finParams, angleChangePerDt2);\n      \n      // 最大フィンたわみ量を更新\n      if (finDeflection > maxFinDeflection) {\n        maxFinDeflection = finDeflection;\n      }\n    } else {\n      finDeflection = 0;\n    }\n\n    // パラシュートフェーズ\n    if (isParachuteActive) {\n      // パラシュートの抗力計算\n      const Cd = 0.775; // パラシュートの抗力係数\n      const rho = 1.225; // 空気密度 (kg/m³)\n      const Area = PI * Math.pow(parachuteDiameter / 2, 2);\n      const Dp = 0.5 * Cd * rho * velocity * velocity * Area;\n      \n      // 速度方向への抗力\n      if (velocity > 0.001) {\n        Fx = -Dp * (prev_vx / velocity);\n        Fy = -Dp * (prev_vy / velocity);\n      }\n\n      // 横風の影響を追加（高度に応じた風速を使用）\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = parachuteDiameter * parachuteDiameter * 0.785; // パラシュートの投影面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      Fx -= Dw; // 横風の影響を追加\n      \n      // 重力の追加\n      Fy -= mass_kg * g;\n      \n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n      \n      // トルク計算 - パラシュート展開後は発射角度を維持する\n      const initialOmega = angle * Math.PI / 180;\n      if (Math.abs(adjustedOmega - initialOmega) > 0.01) {\n        // 簡易的なトルク - 後でより正確な計算に置き換え\n        torque = (initialOmega - adjustedOmega) * 0.001;\n      }\n    } \n    else if (isParachuteEjected && !isParachuteActive) {\n      // パラシュート展開中\n      Fy = -mass_kg * g;\n      \n      // 軽い空気抵抗\n      if (velocity > 0.001) {\n        const dragCoefficient = 0.1;\n        Fx = -dragCoefficient * prev_vx;\n        Fy -= dragCoefficient * prev_vy;\n      }\n\n      // 横風の影響を小さく追加（高度に応じた風速を使用）\n      const rho = 1.225; // 空気密度\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = bodyDiameter * bodyLength * 0.5; // 半分展開時の面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      Fx -= Dw * 0.5; // 展開中なので横風の影響を半分に\n      \n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n      \n      // トルク計算 - パラシュート展開中も発射角度に強く引っ張られる\n      const initialOmega = angle * Math.PI / 180;\n      // 簡易的なトルク - 後でより正確な計算に置き換え\n      torque = (initialOmega - adjustedOmega) * 0.0005;\n    } \n    else {\n      // 通常飛行フェーズ\n      \n      // ロケットの抗力計算 - ノーズ形状に基づく抗力係数を使用\n      const Cd = noseCd; \n      const rho = 1.225; // 空気密度\n      const Area = PI * Math.pow(bodyDiameter / 2, 2) + finwidth_m * finThickness_m * 4;\n      const Dt = 0.5 * Cd * rho * velocity * velocity * Area;\n      \n      // 横風の抗力計算（高度に応じた風速を使用）\n      const Cdw = 0.25; // 横風の抗力係数\n      const S = bodyDiameter * bodyLength; // ロケットの側面積\n      const Dw = 0.5 * Cdw * rho * Math.abs(effectiveWindSpeed) * effectiveWindSpeed * S;\n      \n      if (time < thrustEndTime) {\n        // エンジン推力フェーズ\n        const thrustIndex = Math.min(Math.floor(time / dt), thrustData.length - 1);\n        thrust = thrustData[thrustIndex];\n        \n        // 推力サンプルをトルク計算用に累積\n        avgThrustForTorque += thrust;\n        thrustSamplesCount++;\n        \n        if (onLaunchRail) {\n          // 発射台上での運動\n          if (angle === 0) {\n            // 垂直発射\n            Fy = thrust - mass_kg * g;\n            Fx = -Dw; // 横風の影響のみ\n          } else {\n            // 角度付き発射 (修正した式)\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g;\n            Fx = thrust * Math.sin(adjustedOmega) - Dw; // 横風の影響を追加\n          }\n          \n          // 発射台上は角度固定\n          torque = 0;\n        } else {\n          // 自由飛行（推力あり）\n          if (velocity > 0.001) {\n            // 修正: 推力と抗力の分解方法を修正\n            // T*sinθ - Dt*sinθ - Dw, T*cosθ - m*g - Dt*cosθ\n            Fx = thrust * Math.sin(adjustedOmega) - Dt * Math.sin(adjustedOmega) - Dw;\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g - Dt * Math.cos(adjustedOmega);\n          } else {\n            // 速度がほぼゼロの場合\n            Fx = thrust * Math.sin(adjustedOmega) - Dw;\n            Fy = thrust * Math.cos(adjustedOmega) - mass_kg * g;\n          }\n          \n          // トルク計算 - 推力フェーズ\n          if (velocity > 1.0) {\n            const flightAngle = Math.atan2(prev_vx, prev_vy);\n            \n            try {\n              // 新しいモーメント計算関数を使用\n              const ML = calculateLiftMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n              const MD = calculateDragMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n              const MW = calculateWindMoment(rocketParams.noseHeight, bodyDiameter, rocketParams.bodyHeight, effectiveWindSpeed, adjustedOmega, projectedAreas.totalFinArea, centerOfPressure.centerOfPressure, rocketParams.centerOfGravity);\n              const MT = calculateThrustMoment(thrust, rocketParams.centerOfGravity, adjustedOmega, flightAngle, rocketParams);\n              \n              // トルク値の検証 - 無限大や非数値をチェック\n              if (!isFinite(ML) || isNaN(ML)) torque += 0;\n              else if (!isFinite(MD) || isNaN(MD)) torque += 0;\n              else if (!isFinite(MW) || isNaN(MW)) torque += 0;\n              else if (!isFinite(MT) || isNaN(MT)) torque += 0;\n              else {\n                // 合計トルク - 上限設定を追加\n                const rawTorque = ML + MD + MW + MT;\n                \n                // トルク値が小さすぎる問題を解決するために、最小トルク閾値を設定\n                const MIN_TORQUE_THRESHOLD = 0.0001;\n                \n                // トルクの絶対値が閾値以下の場合、符号を保持して最小値を使用\n                if (Math.abs(rawTorque) > 0 && Math.abs(rawTorque) < MIN_TORQUE_THRESHOLD) {\n                  torque = Math.sign(rawTorque) * MIN_TORQUE_THRESHOLD;\n                } else {\n                  // 通常のトルク制限\n                  torque = Math.max(-1.0, Math.min(1.0, rawTorque));\n                }\n                \n                // デバッグ用ログ - トルク計算の詳細を表示\n                if (Math.abs(torque) > 0.001 || Math.abs(ML) > 0.001 || Math.abs(MD) > 0.001 || Math.abs(MW) > 0.001 || Math.abs(MT) > 0.001) {\n                  console.log(`Thrust Torque components (t=${time.toFixed(2)}): ML=${ML.toFixed(6)}, MD=${MD.toFixed(6)}, MW=${MW.toFixed(6)}, MT=${MT.toFixed(6)}, Total=${torque.toFixed(6)}`);\n                }\n              }\n              \n              // ±4°と±18°の場合のトルク補正\n              if (Math.abs(angle) === 4 || Math.abs(angle) === 18) {\n                torque *= 1.2; // 20%増加\n              }\n            } catch (error) {\n              // エラーが発生した場合はトルクをゼロにして続行\n              console.error('Torque calculation error:', error);\n              torque = 0;\n            }\n          }\n        }\n      } else {\n        // 推力終了時のフラグを設定\n        if (!thrustEndFlag) {\n          thrustEndFlag = true;\n          keyPoints.thrustEnd = { time, height: y, speed: vy };\n        }\n        \n        // 慣性飛行（推力なし）- ここでは推力T=0\n        \n        if (velocity > 0.001) {\n          // 修正: Fx = -Dt*sinθ - Dw, Fy = -m*g - Dt*cosθ\n          Fx = -Dt * Math.sin(adjustedOmega) - Dw;\n          Fy = -mass_kg * g - Dt * Math.cos(adjustedOmega);\n        } else {\n          Fx = -Dw;\n          Fy = -mass_kg * g;\n        }\n        \n        // トルク計算 - 慣性飛行フェーズ\n        if (velocity > 0.5) {\n          const flightAngle = Math.atan2(prev_vx, prev_vy);\n          \n          // 新しいモーメント計算メソッドを使用\n          try {\n            // 新しいモーメント計算関数を使用\n            const ML = calculateLiftMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n            const MD = calculateDragMoment(velocity, adjustedOmega, flightAngle, rocketParams, projectedAreas.sideArea, aerodynamicCenter.aerodynamicCenter, rocketParams.centerOfGravity);\n            const MW = calculateWindMoment(rocketParams.noseHeight, bodyDiameter, rocketParams.bodyHeight, effectiveWindSpeed, adjustedOmega, projectedAreas.totalFinArea, centerOfPressure.centerOfPressure, rocketParams.centerOfGravity);\n            // 推力ゼロなのでMTは0\n          \n            // 合計トルク\n            const rawTorque = ML + MD + MW;\n            \n            // トルク値が小さすぎる問題を解決するために、最小トルク閾値を設定\n            const MIN_TORQUE_THRESHOLD = 0.0001;\n            \n            // トルクの絶対値が閾値以下の場合、符号を保持して最小値を使用\n            if (Math.abs(rawTorque) > 0 && Math.abs(rawTorque) < MIN_TORQUE_THRESHOLD) {\n              torque = Math.sign(rawTorque) * MIN_TORQUE_THRESHOLD;\n            } else {\n              // 通常のトルク制限\n              torque = Math.max(-1.0, Math.min(1.0, rawTorque));\n            }\n            \n            // デバッグ用ログ - トルク計算の詳細を表示\n            if (Math.abs(torque) > 0.001 || Math.abs(ML) > 0.001 || Math.abs(MD) > 0.001 || Math.abs(MW) > 0.001) {\n              console.log(`Inertial Torque components (t=${time.toFixed(2)}): ML=${ML.toFixed(6)}, MD=${MD.toFixed(6)}, MW=${MW.toFixed(6)}, Total=${torque.toFixed(6)}`);\n            }\n          } catch (error) {\n            console.error('Torque calculation error:', error);\n            torque = 0;\n          }\n          \n          // ±4°と±18°の場合のトルク補正\n          if (Math.abs(angle) === 4 || Math.abs(angle) === 18) {\n            torque *= 1.2; // 20%増加\n          }\n        }\n      }\n      \n      // 加速度計算\n      ax = Fx / mass_kg;\n      ay = Fy / mass_kg;\n    }\n\n    // トルクの累積\n    totalTorque += torque;\n    stepCounter++;\n\n    // 角度の更新（dt2間隔で）\n    if (stepCounter >= ANGLE_STEPS_PER_UPDATE) {\n      try {\n        // トルクの平均を計算\n        const avgTorque = totalTorque; // const avgTorque = totalTorque / stepCounter???????\n        \n        // トルクが非数値または無限大の場合はゼロにリセット\n        const safeAvgTorque = isFinite(avgTorque) && !isNaN(avgTorque) ? avgTorque : 0;\n        \n        // 最小トルク保証 - これにより姿勢変化が確実に発生する\n        const MIN_TORQUE = 0.00001;\n        let effectiveTorque = safeAvgTorque;\n        if (Math.abs(safeAvgTorque) > 0 && Math.abs(safeAvgTorque) < MIN_TORQUE) {\n          effectiveTorque = Math.sign(safeAvgTorque) * MIN_TORQUE;\n        }\n        \n        // トルク計算のデバッグ出力\n        if (Math.abs(effectiveTorque) > 0.001) {\n          console.log(`Torque calculation (t=${time.toFixed(2)}): avgTorque=${safeAvgTorque.toFixed(6)}, effectiveTorque=${effectiveTorque.toFixed(6)}, momentOfInertia=${momentOfInertia.toFixed(6)}`);\n        }\n        \n        // 角加速度の計算: α = M/I\n        angularAcceleration = effectiveTorque / momentOfInertia;\n        \n        // 角速度の更新: ω = ω0 + α*dt2\n        const oldAngularVelocity = angularVelocity;\n        angularVelocity = angularVelocity + angularAcceleration * dt2;\n        \n        // 角速度に上限を設定\n        angularVelocity = Math.max(-3, Math.min(3, angularVelocity));\n        \n        // 角度変化の計算: ν = ω*dt2\n        angleChangePerDt2 = angularVelocity * dt2;\n        \n        // 最小角度変化保証 - 非常に小さな値でも角度更新を保証\n        const MIN_ANGLE_CHANGE_PER_DT2 = 0.001; // 角度変化を強調するために増加（0.0001→0.001）\n\n        if (Math.abs(angleChangePerDt2) > 0 && Math.abs(angleChangePerDt2) < MIN_ANGLE_CHANGE_PER_DT2) {\n          angleChangePerDt2 = Math.sign(angleChangePerDt2) * MIN_ANGLE_CHANGE_PER_DT2;\n        }\n        \n        // 角度変化のデバッグ出力\n        if (Math.abs(oldAngularVelocity - angularVelocity) > 0.001 || Math.abs(angleChangePerDt2) > 0.001) {\n          console.log(`Angle change calculation (t=${time.toFixed(2)}): angularAcceleration=${angularAcceleration.toFixed(6)}, angularVelocity=${angularVelocity.toFixed(6)}, angleChangePerDt2=${angleChangePerDt2.toFixed(6)}`);\n        }\n        \n        // 姿勢安定性チェック（パラシュート展開前かつ推力終了後の慣性飛行中）\n        if (!isParachuteEjected && thrustEndFlag) {\n          // dt2時間あたりの角度変化量（度数法）\n          const angleChangePerDt2Degrees = angleChangePerDt2 * 180 / Math.PI;\n          \n          // 最大角度変化量を更新\n          if (Math.abs(angleChangePerDt2Degrees) > Math.abs(maxAngleChangePerDt2)) {\n            maxAngleChangePerDt2 = angleChangePerDt2Degrees;\n          }\n          \n          // 角度変化量が±10°を超える場合にNG判定（0.2秒間の変化量）\n          if (Math.abs(angleChangePerDt2Degrees) > 10) {\n            isAngleStableOK = false;\n          }\n        }\n        \n        // カウンターとトルク累積のリセット\n        stepCounter = 0;\n        totalTorque = 0;\n        avgThrustForTorque = 0;\n        thrustSamplesCount = 0;\n      } catch (error) {\n        // エラーが発生した場合でも安全に処理\n        console.error('Angle update error:', error);\n        stepCounter = 0;\n        totalTorque = 0;\n        avgThrustForTorque = 0;\n        thrustSamplesCount = 0;\n      }\n    }\n    \n    // 物理ベースの角度更新を強化 - この部分は常に適用される\n    // 角度の更新 - angleChangePerDt2の値を確実に反映\n    const physicsBasedAngleChange = angleChangePerDt2 / ANGLE_STEPS_PER_UPDATE;\n\n    // 物理ベースの変化が非常に小さい場合の最小変化量を設定\n    const MIN_ANGLE_CHANGE = 0.0001; // ラジアン単位での最小角度変化\n\n    // 物理ベースの姿勢変化を適用\n    if (PHYSICAL_ATTITUDE_CONTROL) {\n      if (Math.abs(physicsBasedAngleChange) > 0 && Math.abs(physicsBasedAngleChange) < MIN_ANGLE_CHANGE) {\n        // 変化量が小さすぎる場合は適切な最小値を使用\n        omega += Math.sign(physicsBasedAngleChange) * MIN_ANGLE_CHANGE;\n      } else {\n        // 通常の物理ベースの角度更新\n        omega += physicsBasedAngleChange;\n      }\n  \n      // 角度変化のデバッグ出力 - 実際に何が起きているかを確認\n      if (Math.abs(physicsBasedAngleChange) > 0.001) {\n        console.log(`Applied physics angle change (t=${time.toFixed(2)}): ${physicsBasedAngleChange.toFixed(6)}, new omega=${omega.toFixed(6)}`);\n      }\n    }\n    \n    // 拡張姿勢制御ロジック - 風見効果など\n    if (ENHANCED_ATTITUDE_CONTROL) {\n      // 発射台を離れた後かつパラシュート展開前\n      if (!onLaunchRail && !isParachuteEjected) {\n        // 速度ベクトルの方向（飛行角）\n        const flightAngle = Math.atan2(vx, vy);\n    \n        // 推力フェーズと慣性飛行フェーズで完全に分ける\n        if (thrustEndFlag) {\n          //===========================================\n          // 慣性飛行中 - 風見効果を無効化\n          //===========================================\n          \n          // 目標姿勢角は常に速度方向（風の影響を受けない）\n          const targetOmega = flightAngle;\n          \n          // 姿勢角変化のスピード係数 - 非常に小さな値\n          const adjustRate = Math.min(0.05, 0.002 * velocity);\n          \n          // 姿勢角を目標角に近づける（緩やかに）\n          const newOmega = omega * (1.0 - adjustRate) + targetOmega * adjustRate;\n          \n          // 変化量の制限も小さめ\n          // 変化量の制限を大きくする - 約11.5度/フレーム\n          const maxChange = 0.2;\n          if (Math.abs(newOmega - omega) > maxChange) {\n            omega += Math.sign(newOmega - omega) * maxChange;\n          } else {\n            omega = newOmega;\n          }\n          \n          // デバッグ用ログ - 拡張姿勢制御の適用を確認\n          if (Math.abs(newOmega - omega) > 0.01) {\n            console.log(`Applied enhanced attitude control (inertial): targetOmega=${targetOmega.toFixed(6)}, newOmega=${newOmega.toFixed(6)}`);\n          }\n          \n        } else {\n          //===========================================\n          // 推力飛行中 - 風見効果を適用\n          //===========================================\n          \n          // 風向きベクトル\n          const windAngle = effectiveWindSpeed > 0 ? 0 : Math.PI; // 風が左から右:0度、右から左:180度\n    \n          // 風向きに対する垂直方向 (±90度)\n          const perpendicularToWind1 = windAngle + Math.PI/2;  // +90度\n          const perpendicularToWind2 = windAngle - Math.PI/2;  // -90度\n          \n          // 目標姿勢角の決定\n          let targetOmega;\n          \n          if (Math.abs(effectiveWindSpeed) < 0.5) {\n            // 風が弱い場合は速度方向に合わせる\n            targetOmega = flightAngle;\n          } else {\n            // 風が強い場合、風向きも考慮する\n            \n            // 風上に向かっているか判定 - 風向きと速度が「逆」のとき風上\n            const isMovingUpwind = (effectiveWindSpeed < 0 && vx > 0) || \n                                   (effectiveWindSpeed > 0 && vx < 0);\n            \n            if (isMovingUpwind) {\n              // 風上に向かう場合は風に対して垂直方向を超えない\n              if (effectiveWindSpeed < 0) {\n                // 右からの風の場合、-90度まで（右向き）\n                targetOmega = Math.max(flightAngle, perpendicularToWind2);\n              } else {\n                // 左からの風の場合、+90度まで（左向き）\n                targetOmega = Math.min(flightAngle, perpendicularToWind1);\n              }\n            } else {\n              // 風下に向かう場合は直接速度方向\n              targetOmega = flightAngle;\n            }\n          }\n          \n          // 推力飛行中の姿勢角変化のスピード係数（現状維持）\n          const adjustRate = Math.min(0.05, 0.002 * velocity);\n          \n          // 風速に応じた調整\n          const windFactor = Math.min(0.8, Math.abs(effectiveWindSpeed) / 6.0);\n          const finalAdjustRate = adjustRate * (1.0 + windFactor);\n          \n          // 姿勢角を目標角に近づける\n          const newOmega = omega * (1.0 - finalAdjustRate) + targetOmega * finalAdjustRate;\n          \n          // 変化量の制限を大きくする - 約11.5度/フレーム\n          const maxChange = 0.2;\n          if (Math.abs(newOmega - omega) > maxChange) {\n            omega += Math.sign(newOmega - omega) * maxChange;\n          } else {\n            omega = newOmega;\n          }\n          \n          // デバッグ用ログ - 拡張姿勢制御の適用を確認\n          if (Math.abs(newOmega - omega) > 0.01) {\n            console.log(`Applied enhanced attitude control (thrust): targetOmega=${targetOmega.toFixed(6)}, newOmega=${newOmega.toFixed(6)}`);\n          }\n        }\n      }\n    }\n\n    // 速度の更新\n    vx = vx + ax * dt;\n    vy = vy + ay * dt;\n    \n    // 速度制限（最大100m/s）\n    const MAX_SPEED = 100; // m/s\n    const currentSpeed = Math.sqrt(vx * vx + vy * vy);\n    if (currentSpeed > MAX_SPEED) {\n      const factor = MAX_SPEED / currentSpeed;\n      vx *= factor;\n      vy *= factor;\n    }\n    \n    // 角速度の制限\n    const MAX_ANGULAR_VELOCITY = 5; // rad/s\n    angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, angularVelocity));\n    \n    // 位置の更新\n    if (onLaunchRail) {\n      // 発射台上の動き\n      if (angle === 0) {\n        // 垂直発射\n        x = 0;\n        y = y + vy * dt;\n      } else {\n        // 角度付き発射\n        const railDistance = Math.min(distanceFromStart + velocity * dt, launchRailLength);\n        x = railDistance * Math.sin(omega);\n        y = railDistance * Math.cos(omega);\n      }\n    } else {\n      // 自由飛行の位置更新\n      x = x + vx * dt;\n      y = y + vy * dt;\n    }\n    \n    // 最高高度と最高速度の更新\n    if (y > maxHeight) {\n      maxHeight = y;\n      keyPoints.maxHeight = { time, height: maxHeight, speed: vy };\n    }\n    \n    if (currentSpeed > maxSpeed) {\n      maxSpeed = currentSpeed;\n    }\n    \n    // 最大水平距離の更新\n    if (Math.abs(x) > maxDistance) {\n      maxDistance = Math.abs(x);\n    }\n    \n    // データの記録\n    data.push({ \n      time,\n      physicsX: x, // 物理座標系でのx（メートル単位）\n      physicsY: y, // 物理座標系でのy（メートル単位）\n      height: y, // メートル単位\n      vx: vx,\n      vy: vy,\n      ax: ax,\n      ay: ay,\n      speedMagnitude: Math.sqrt(vx * vx + vy * vy),\n      accelerationMagnitude: Math.sqrt(ax * ax + ay * ay),\n      angularVelocity,\n      angularAcceleration,\n      isParachuteEjected,\n      isParachuteActive,\n      parachuteDeploymentProgress,\n      omega,\n      torque,\n      angleChangePerDt2,\n      horizontalDistance: Math.abs(x), // 水平距離の絶対値を追加\n      finDeflection, // フィンのたわみ量を追加\n      angleDeviationDegrees: (omega * 180 / Math.PI) - initialOmegaDegrees, // 初期角度からの偏差を追加\n      effectiveWindSpeed // 実効風速を記録\n    });\n\n    time += dt;\n  }\n\n  console.log(`シミュレーション完了: 最高高度=${maxHeight.toFixed(2)}m, 最高速度=${maxSpeed.toFixed(2)}m/s, 最大水平距離=${maxDistance.toFixed(2)}m`);\n  console.log(`推力終了時 (${keyPoints.thrustEnd.time.toFixed(2)}s): 高度=${keyPoints.thrustEnd.height.toFixed(2)}m, 速度=${keyPoints.thrustEnd.speed.toFixed(2)}m/s`);\n  console.log(`最高点 (${keyPoints.maxHeight.time.toFixed(2)}s): 高度=${keyPoints.maxHeight.height.toFixed(2)}m, 速度=${keyPoints.maxHeight.speed.toFixed(2)}m/s`);\n  console.log(`最大フィンたわみ量: ${maxFinDeflection.toFixed(4)}mm`);\n  console.log(`最大角度変化量/dt2: ${maxAngleChangePerDt2.toFixed(2)}°`);\n  console.log(`姿勢安定性判定: ${isAngleStableOK ? 'OK' : 'NG'}`);\n\n  // 投影面積と体積の情報を追加\n  console.log(`投影面積 - 正面: ${projectedAreas.frontalArea.toFixed(5)}m², 側面: ${projectedAreas.sideArea.toFixed(5)}m²`);\n  console.log(`体積 - ノーズ: ${volumes.noseVolume.toFixed(6)}m³, ボディ: ${volumes.bodyVolume.toFixed(6)}m³, 合計: ${volumes.totalVolume.toFixed(6)}m³`);\n  console.log(`圧力中心位置: ${centerOfPressure.centerOfPressure.toFixed(2)}mm, 空力中心位置: ${aerodynamicCenter.aerodynamicCenter.toFixed(2)}mm`);\n  console.log(`静安定用圧力中心位置: ${stabilityCenterOfPressure.stabilityCenterOfPressure.toFixed(2)}mm`);\n  console.log(`静安定マージン (標準): ${staticMargins.standardStaticMargin.toFixed(2)}, (静安定用): ${staticMargins.stabilityStaticMargin.toFixed(2)}`);\n  \n  return {\n    data,\n    maxHeight,\n    maxSpeed,\n    maxDistance,\n    maxFinDeflection,\n    keyPoints,\n    angleStability: {\n      maxAngleChangePerDt2,\n      isAngleStableOK\n    },\n    projectedAreas,  // 投影面積データを追加\n    volumes,         // 体積データを追加\n    pressureCenter: centerOfPressure,  // 圧力中心データを追加\n    aerodynamicCenter,  // 空力中心データを追加\n    stabilityCenterOfPressure, // 静安定用圧力中心を追加\n    staticMargins,  // 静安定マージンを追加\n    calculations: {\n      aerodynamicCenter: Math.round(aerodynamicCenter.aerodynamicCenter),\n      pressureCenter: Math.round(centerOfPressure.centerOfPressure),\n      stabilityCenterOfPressure: Math.round(stabilityCenterOfPressure.stabilityCenterOfPressure),\n      standardStaticMargin: parseFloat(staticMargins.standardStaticMargin.toFixed(2)),\n      stabilityStaticMargin: parseFloat(staticMargins.stabilityStaticMargin.toFixed(2)),\n      finDivergenceSpeed: Math.round(calculateFinDivergenceSpeed(rocketParams)),\n      finFlutterSpeed: Math.round(calculateFinFlutterSpeed(rocketParams))\n    }\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}